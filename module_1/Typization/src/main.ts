import "./style.css";

/* ======================================================================================================================
Опис простих (скалярних) типів
====================================================================================================================== */

// У базових типах ми розбиратимемо ті типи, які є в JavaScript, і почнемо зі скалярних типів. Їх називають скалярними, тому що це прості типи, що містять одне значення.

// // boolean: логічний тип даних, який може приймати значення true або false.
// let isDone: boolean = false;

// // number: числовий тип даних для цілих та дійсних чисел.
// let decimal: number = 6; // десяткові
// let float: number = 3.14; // речові або число з плаваючою крапкою
// let hex: number = 0xf00d; // шістнадцяткове
// let binary: number = 0b1010; // двійкове
// let octal: number = 0o744; // вісімкове

// // string: текстовий тип даних для символів та рядків
// let color: string = "blue";

// // null та undefined: два спеціальні типи, що відповідають значенням null і undefined відповідно.
// let empty: null = null;
// let notParam: undefined = undefined;

// // Також не обов'язково вказувати тип даних, якщо ви передаєте його явно.
// const num = 10;
// const str = "Some str";
// const bool = true;
// const empty = null;
// const notParam = undefined;

// // Давайте спробуємо передати в аргумент функції тип даних:
// function foo(num: number, str: string, bool: boolean, empty: null) {
//   // Some logic
// }

// // Також, якщо ми задаємо значення за замовчуванням у функції, тип вказувати не потрібно.
// function foo(num = 10, str = "Some str", bool = true, empty = null) {
//   // Some logic
// }

/* ======================================================================================================================
Складні типи
====================================================================================================================== */
// Object

// У JavaScript, а отже, і у TypeScript тип Object
// використовується для зберігання колекції даних
// або більш складних структур. Він є структурою
// даних, яка може містити дані різних типів.

// Існує тип даних object:

// const obj: object = {};

// const obj: {} = {};

// Як і зі скалярними типами даних, ми можемо не уточнювати, що це Object:

// let user = {
//   name: "Tom",
//   age: 30,
// };

// Однак, використання типу object не дає нам
// особливого контролю над формою цього об'єкта.

// Ми можемо використовувати більш точну анотацію,
// за допомогою типу об'єкта:

// let user: { name: string; age: number } = {
//   name: "Tom",
//   age: 30,
// };

// Тепер, якщо ми не вкажемо якусь властивість, то отримаємо помилку.

// let user: { name: string; age: number } = {
//   age: 30,
// };

// let userNameLikeNumber: { name: string; age: number } = {
//   name: 10,
//   age: 30,
// };

// export {};

// Але погодьтеся, що не дуже зручно дублювати так
// типи та описувати їх перед присвоєнням. Ми можемо
// винести тип окремо за допомогою ключового слова type:

// type User = {
//   name: string;
//   age: number;
// };

// let user: User = {
//   name: "Tom",
//   age: 30,
// };

// let userJack: User = {
//   name: 'Jack',
//   age: 25
// };

// export {}

// Тут User — це наш власний тип, який ми створили
// для представлення користувача. Ми можемо
// використовувати цей тип скрізь, і ми використали
// його для двох змінних: user та userJack.

// Крім того, ми можемо використати interface для визначення об'єкта:

// interface User {
//   name: string;
//   age: number;
// }

// let user: User = {
//   name: "Tom",
//   age: 30,
// };

// export {};

// Загалом, типи та інтерфейси дозволяють покращити
// структуру та повторне використання коду, а також
// допомагають уникнути помилок за рахунок суворої типізації.

// В цьому разі немає суттєвої різниці між type та interface, у
// майбутніх блоках ми розберемо їх докладніше.

//  ================================

// Array

// Масиви в TypeScript — це структури, які є впорядкованим
// набором елементів. Для оголошення масиву в TypeScript
// використовується конструкція з квадратними дужками []
// або загальний тип Array.

// Якщо ми хочемо вказати масив рядків, ми робимо це так:

// let arrString: string[];

// Якщо ми спробуємо передати в нього не рядковий тип
// даних, ми отримаємо помилку.

// let arrString: string[];
// arrString = ["text", 1];
// export {}

// Як бачимо, число підсвітилося як помилка.
// Давайте створимо масив чисел:

// let arrNumber: number[];

// Тепер він може містити лише числа, і будь-який
// інший тип даних буде викликати помилку.

// let arrNumber: number[];
// arrNumber = [1, 'text'];
// export {}

// Крім того, масиви в TypeScript можуть
// бути багатовимірними. Наприклад:

// let matrix: number[][] = [
//   [1, 2],
//   [3, 4],
// ];

// Масиви також можуть містити елементи різних типів. Наприклад:
// let mixed: (number | string)[] = [1, "two"];

// Ми також можемо вказати тип масиву через узагальнення (generic):
// let numbers: Array<number> = [1, 2, 3, 4, 5];

// Можна визначити масив об'єктів у TypeScript. Наприклад:

// let users: {
//   name: string;
//   age: number;
// }[] = [
//   { name: "Tom", age: 30 },
//   { name: "Jack", age: 25 },
//   { name: "Alice", age: 32 },
// ];

// Або з використанням більш зручного запису:

// type User = {
//   name: string;
//   age: number;
// };

// let users: User[] = [
//   { name: "Tom", age: 30 },
//   { name: "Jack", age: 25 },
//   { name: "Alice", age: 32 },
// ];

// Тепер якщо якесь значення об'єкта буде не того типу, ми отримаємо помилку.

// type User = {
//   name: string;
//   age: number;
// };

// let users: User[] = [{ name: "Tom", age: '30' }];

// Це демонструє всю силу суворої типізації.
// Але іноді нам це не потрібно,
// і тоді ми можемо скористатися типом даних any:

// let arrAny: any[];

// У такому масиві можна зберігати будь-що.

// let arrAny: any[];
// arrAny = [123, "text", { name: "Tom" }, [1, 2, 3]];
// export { };

// Але не варто зловживати any, інакше TypeScript швидко перетвориться на JavaScript :)

/* ======================================================================================================================
Типи для змінних та аргументів
====================================================================================================================== */
// Any

// Any — це тип даних, який використовується, коли ви
// не знаєте, який тип даних може міститися у змінній.
// Змінні з типом any дозволяють викликати будь-які
// властивості та методи без перевірок типів. Цей тип
// даних робить змінну аналогічною змінною в JavaScript,
// що дозволяє передавати в неї будь-які значення. Однак,
// варто уникати використання типу any, оскільки це обходить
// переваги суворої типізації у TypeScript.

// let notSure: any = 4;
// notSure = "maybe a string instead";
// notSure = false;
// notSure = {};

// let num: number;
// num = notSure;
// export {};

// Основною проблемою використання типу any в TypeScript є
// відсутність суворої типізації. Зберігай його у змінну, де вказано тип.

// let num: number;
// num = notSure;

// У цьому випадку TypeScript не викличе помилку на етапі компіляції,
// адже any потенційно може являти собою будь-який тип даних. Навіть
// якщо з коду зрозуміло, що notSure — це об'єкт, а не число.

// Але в яких випадках він може бути корисним? Наприклад, коли ми
// працюємо з бібліотекою на JavaScript, що може повертати різні
// типи даних, або в ситуаціях, коли конкретний тип даних не має
// значення в контексті нашого коду.

// let data: any = fetchData();

// Або візьмемо інший приклад, коли функція приймає аргумент,
// тип якого нам не відомий, і який загалом не важливий у цьому
// контексті. Це може бути, наприклад, певна колбек-функція.

// function fetchUserData(id: string, callback: (data: any) => void): void {
//   // Тут може бути якийсь запит, але ми його заповнимо самі
//   const responseData = { name: "Tom" };
//   callback(responseData);
// }

// // Використання функції:
// fetchUserData("123", (data) => {
//   console.log(data.name); // TypeScript не викличе помилку, навіть якщо поле name не існує
// });

// export {};

// Це дозволяє нам працювати з даними, не знаючи їхньої точної структури.
// Однак це також означає, що TypeScript не зможе надати нам підказки про
// те, які властивості та методи доступні для об'єкта data.

// Unknown

// Тип unknown у TypeScript багато в чому схожий на any, але він
// забезпечує більше безпеки під час роботи зі змінними. Якщо ми
// спробуємо присвоїти значення змінної типу unknown іншій змінній
// з конкретним типом без явного приведення типів, TypeScript
// видасть помилку. Це допомагає запобігти випадковому присвоєнню
// значень неправильного типу.

// let notSure: unknown = 4;
// notSure = "maybe a string instead";
// notSure = false;

// let num: number;
// num = notSure;
// export {};

// Як бачимо, нам не вдалося зберегти значення
// змінної notSure в змінну num.

// Тип unknown підходить для сценаріїв, коли ви
// не знаєте точного типу даних, але все ж таки
// хочете підтримувати сувору перевірку типів.
// Змінні цього типу слід перевіряти перед їх використанням.

// Візьмемо для прикладу таку ситуацію: Ви отримуєте
// дані з API та не знаєте їхнього точного формату.
// У цьому випадку вам потрібно буде провести уточнення типів.

// function fetchUserData() {
//   return "Tom";
// }

// let userData: unknown = fetchUserData(); // fetchUserData повертає невідомі дані
// if (typeof userData === "string") {
//   console.log(userData.toUpperCase()); // OK, тепер ми знаємо, що це рядок
// }

// Отже, ми можемо бути впевнені, що обробляємо дані правильного типу.

// Tuple

// Кортеж, особливо популярний у мовах програмування як Python, це
// незмінний масив. У TypeScript це тип даних, що дозволяє визначити
// масив з фіксованою кількістю елементів, типи яких відомі, але не
// обов'язково повинні бути однаковими.

// Він створюється як масив, але замість значень ми передаємо
// типи даних, наприклад, [string, number].

// let tupleType: [string, boolean];
// tupleType = ["hello", true]; // OK
// tupleType = [true, "hello"]; // Error. Неправильні типи
// tupleType = ["hello", true, true]; // Error. Більше значень ніж у tuple

// export {};

// Кортежі зручні, коли нам потрібно зберегти в масив
// фіксовані значення, наприклад, день, місяць та рік.

// let date: [number, number, number];
// date = [7, 11, 2023]; // OK

// Але є нюанс: якщо ми додамо елемент у кортеж
// через метод push, то TypeScript не заперечуватиме,
// він не відстежує реальний вміст масиву.

// let fixed: [string, number];
// fixed = ["Text", 10];
// fixed.push("Add this text");
// export {};

// Як ми бачимо, компілятор не зміг розібратися і видати помилку.

// Однак, TypeScript надає гнучкі можливості для роботи з
// кортежами, включно з використанням оператора розширення
// (...) для створення кортежів змінної довжини.

// let tuple: [string, ...number[]];
// tuple = ["hello", 42, 100, 200];

// У цьому випадку перший елемент
// кортежу має бути рядком, проте всі наступні — числами.

// Enum

// Ця структура настільки широко використовується, що в
// TypeScript вирішили додати її як тип даних. Цей тип
//  називається enum і, згідно з хорошими практиками
// програмування, імена змінних цього типу мають починатися з великої літери.

// enum Role {
//   ADMIN,
//   USER,
// }

// Розглянемо застосування на прикладі користувача, який має певні права.

// enum Role {
//   ADMIN,
//   USER,
// }

// const person = {
//   role: Role.ADMIN,
// };

// if (person.role === Role.ADMIN) {
//   console.log("Role", Role.ADMIN); // Role:  0
//   console.log(Role[Role.ADMIN]); // значення enum // "ADMIN"
// }

// export {};

// Enum являє собою набір констант, що робить код більш
//  зрозумілим. Як ми бачили у минулому прикладі,
//  значеннями enum зазвичай є числа, проте ми можемо задати свої значення.

// enum UserStatus {
//   Active = "ACTIVE",
//   Inactive = "INACTIVE",
//   Banned = "BANNED",
// }

// let status: UserStatus = UserStatus.Active;

// Крім того, ви можете використовувати enum для
// угруповання взаємопов'язаних значень, що може
// бути корисним для спрощення коду та покращення читабельності:

// enum HttpCodes {
//   Ok = 200,
//   BadRequest = 400,
//   Unauthorized = 401,
// }

// function respond(status: HttpCodes) {
//   // handle response
// }

// respond(HttpCodes.Ok);
// export {};

// Коли ми будемо створювати свої типи, детальніше розберемо,
// як enum може допомогти нам у цьому процесі.

// Існує ще така конструкція, як const enum. На відміну від
// звичайного enum, const enum видаляється під час транспіляції
// та не створює додаткового об'єкта в JavaScript.

// Значення const enum вставляють у місце використання у вигляді
// літералів. Це може допомогти покращити продуктивність.

// const enum HttpCodes {
//   Ok = 200,
//   BadRequest = 400,
//   Unauthorized = 401,
// }

// const status = HttpCodes.Ok;

// Після компіляції у JavaScript отримаємо наступний код:

// const status = 200;

// Як видно з прикладу, const enum видаляється зі
// скомпільованого коду і його значення прямо
// вставляється в код. У цьому випадку HttpCodes.
// OK замінився на 200. Це і є ключовою відмінністю
//  const enum від звичайного enum.

// Однак існує одне обмеження використання const enum:
// їх не можна використовувати у виразах, які вимагають
// виконання під час виконання. Це пов'язане з тим, що
// вони замінюються на їхнє значення під час компіляції.

// const enum Test {
//   A = 1,
//   B = 2,
// }

// for (let item in Test) {
//   console.log(item);
// }

// export {};

// ==================

// Union Type

// Union Type у TypeScript дозволяє вказати, що
// значенням може бути один із кількох типів. Це
// дуже зручно, коли хочемо визначити змінну,
// яка може приймати різні типи даних. Типи
// перераховуються через вертикальну риску |

// let mixedType: string | number | boolean;

// Давайте подивимося, як це працює:

// let mixedType: string | number | boolean;

// mixedType = "string"; // Ok
// mixedType = 10; // Ok
// mixedType = true; // Ok
// mixedType = {}; // Error: Type '{}' is not assignable to type 'string | number | boolean'.

// export {};

// Union Type можна також використовувати для аргументів
// функцій. Давайте створимо функцію, яка об'єднує рядки або складає числа.

// function combine(param1: number | string, param2: number | string) {
//   return param1 + param2;
// }
// export {}

// Ми отримуємо помилку, тому що TypeScript просто не знає, рядок там чи число.

// Давайте перевіримо типи у функції.

// function combine(param1: number | string, param2: number | string) {
//   if (typeof param1 === "number" && typeof param2 === "number") {
//     return param1 + param2;
//   } else {
//     return param1.toString() + param2.toString();
//   }
// }
// export {};

// Тепер ми можемо передавати у функцію або числа, або рядки.

// Union Type працює не лише з базовими типами, а й з об'єктами:

// type Dog = {
//   legs: 4;
//   bark: () => void;
// };

// type Fish = {
//   fins: 2;
//   swim: () => void;
// };

// let pet: Dog | Fish;

// У цьому прикладі змінна pet може бути або
// об'єктом типу Dog, або об'єктом типу Fish.

// Однак існує важливе обмеження: коли ми працюємо
// зі змінною Union Type, ми можемо використовувати
// лише ті властивості та методи, які існують у всіх
// типів цього об'єднання. У прикладі вище ми не
// можемо викликати pet.bark(), якщо pet є типом Fish.
// Нам доведеться перевіряти, чи існує цей метод.

// type Dog = {
//   legs: 4;
//   bark: () => void;
// };

// type Fish = {
//   fins: 2;
//   swim: () => void;
// };

// let pet: Dog | Fish;

// // type guard function
// function isDog(pet: Dog | Fish): pet is Dog {
//   return "bark" in pet;
// }

// // Перевіряємо, чи є наш вихованець собакою перед тим, як використовувати метод bark
// if (isDog(pet)) {
//   pet.bark(); // OK, тепер TypeScript знає, що pet - це Dog
// } else {
//   pet.swim(); // TypeScript знає, що якщо pet не Dog, то це має бути Fish
// }

// export {};

// Дуже часто розробники вважають за краще використовувати
// Union Type замість enum для перерахування всіх допустимих
// значень. Це особливо зручно робити у зв'язці з Literal Type.

// =================================

// Intersection Type

// Intersection type є способом об'єднання декількох типів в один.
// Це дозволяє створювати складні типи, комбінуючи прості.
// У TypeScript можна використовувати символ & для створення типу intersection.

// type Employee = {
//   name: string;
//   id: number;
// };

// type Manager = {
//   employees: Employee[];
// };

// type CEO = Employee & Manager;

// const ceo: CEO = {
//   name: "Alice",
//   id: 1,
//   employees: [
//     {
//       name: "Bob",
//       id: 2,
//     },
//   ],
// };

// export {};

// У цьому прикладі CEO є intersection тип Employee і Manager.
//  Це означає, що об'єкт типу CEO повинен містити всі властивості,
// визначені в Employee та Manager.

// ==================================

// Literal Type

// Literal Type — це тип, що набуває конкретного значення.
// З ним ви можете визначити тип змінної так,
// щоб він набував лише певних значень.

// type OneOrTwo = 1 | 2;
// let value: OneOrTwo;
// value = 1; // Ok
// value = 2; // Ok
// value = 3; // Error: Type '3' is not assignable to type 'OneOrTwo'.

// type YesOrNo = "yes" | "no";
// let answer: YesOrNo;
// answer = "yes"; // Ok
// answer = "no"; // Ok
// answer = "maybe"; // Error: Type '"maybe"' is not assignable to type 'YesOrNo'.

// export {};

// Тут OneOrTwo може набувати лише значення 1 або 2,
// YesOrNo може набувати тільки значення "yes" або "no".

// Але давайте розглянемо якийсь бойовий приклад.
// Припустимо, ми маємо функцію, що приймає рядок як
// аргумент і повертає стилі для кнопки в залежності
// від переданого значення.

// type ButtonSize = "small" | "medium" | "large";

// function getButtonSize(size: ButtonSize) {
//   switch (size) {
//     case "small":
//       return { fontSize: "10px", padding: "5px" };
//     case "medium":
//       return { fontSize: "14px", padding: "10px" };
//     case "large":
//       return { fontSize: "18px", padding: "15px" };
//     default:
//       return { fontSize: "14px", padding: "10px" };
//   }
// }

// let myButtonStyle = getButtonSize("medium"); // OK
// myButtonStyle = getButtonSize("extra-large"); // Error: Argument of type '"extra-large"' is not assignable to parameter of type 'ButtonSize'.

// export {};

// Тут, якщо ми спробуємо викликати функцію getButtonStyle
// з аргументом "extra-large", TypeScript видасть помилку
// на етапі компіляції, оскільки "extra-large" не є
// допустимим значенням для ButtonSize.

/* ======================================================================================================================
Типи для методів та функцій
====================================================================================================================== */
// Return Type

// Return type — це тип даних, який функція повертає під
// час її виклику. TypeScript дозволяє вказувати тип значення,
// що повертається для функцій, що допомагає зробити ваш код
// більш зрозумілим і безпечним.

// function greet(): string {
//   return "Hello world";
// }

// let result = greet();

// Розглянемо цей приклад. Тут функція greet має тип значення,
//  що повертається string. Це означає, що ми гарантуємо, що
// ця функція завжди буде повертати рядок, але так само ми і
// контролюємо себе, якщо ми спробуємо змінити цю функцію так,
// щоб вона повертала число, TypeScript видасть помилку,
// контролюючи тим самим нас від ненавмисних змін типу.

// function greet(): string {
//   return 100; // Error: Type 'number' is not assignable to type 'string'
// }

// let result = greet();

// export {};

// Ми отримали помилку, оскільки реальний тип значення,
// що повертається, не збігається з тим, який був оголошений у функції.

// Для стрілочних функцій схожий синтаксис.

// const greet = (): string => {
//   return "Hello world";
// };

// let result = greet();

// Тут greet — це стрілочна функція, яка повертає рядок.
// Ми визначаємо тип значення, що повертається (string)
// після списку аргументів і перед стрілкою (=>).

// Давайте розглянемо ситуацію, де ми хочемо написати функцію,
// що отримує список користувачів та повертає імена цих
// користувачів у вигляді рядка. Ось як ми можемо типізувати таку функцію:

// type User = {
//   id: number;
//   name: string;
// };

// const getUserNames = (users: User[]): string[] => {
//   return users.map((user) => user.name);
// };

// const users: User[] = [
//   { id: 1, name: "Alice" },
//   { id: 2, name: "Bob" },
//   { id: 3, name: "Charlie" },
// ];

// let result = getUserNames(users);
// console.log(result); // ['Alice', 'Bob', 'Charlie']

// export {};

// У цьому прикладі функція getUserNames приймає масив
// об'єктів типу User та повертає масив рядків.

// Вказування типу значення, що повертається — це не
// тільки зручний спосіб документування функцій, але й
// важливий інструмент контролю коректності вашого коду.
// Він дозволяє компілятору TypeScript перевірити, чи
// функція дійсно повертає те, що ви припускали, і
// видати помилку, якщо це не так.

// Важливо також зазначити, що TypeScript здатний
// автоматично визначати типи значень функцій, що
// повертаються, на основі їх реалізації. Так, якщо
// ви не вказали тип значення, що повертається явно,
// але ваша функція повертає, наприклад, рядок,
// TypeScript автоматично присвоїть цій функції
// тип значення, що повертається string.

// function greet() {
//   return "Hello world";
// }

// let result: string = greet();

// export {};

// ======================================================

// Void

// Тип void у TypeScript використовується для позначення
// відсутності будь-якого типу взагалі, і зазвичай використовується
// як тип функцій, що повертається, в якому функції не повертають значення.

// Таких функцій у коді багато, давайте розглянемо на прикладі:

// function logMessage(message: string): void {
//   console.log(message);
// }

// logMessage("Hello world");

// export {};

// У цьому прикладі функція logMessage приймає один
// параметр — message типу string і нічого не повертає,
// тому тип, що повертається — void.

// Тип void часто використовується в callback-функціях
// або функціях зворотного виклику, де ви хочете бути
// впевнені, що функція не повертає значення, і тому не
// важливо, що повертає функція зворотного виклику.

// function doSomething(callback: () => void) {
//   callback();
// }

// doSomething(() => {
//   console.log("Callack function");
// });

// export {};

// У цьому прикладі функція doSomething приймає функцію
// зворотного виклику callback, що не повертає жодного значення.

// ==============================

// Never

// Це коли функція ніколи не закінчується та нічого не повертає.
// Часто тип never використовується для функцій, які завжди викидають
// вийняток або у нескінченних циклах.

// Ось деякі приклади його використання:

// // Функція, яка завжди викидає помилку
// function throwError(message: string): never {
//   throw new Error(message);
// }

// // Функція з нескінченним циклом
// function infiniteLoop(): never {
//   while (true) {}
// }

// export {};

// У першому прикладі функція throwError викидає помилку
// і ніколи не повертає значення, тому тип, що повертається — never.

// У другому прикладі функція infiniteLoop входить у нескінченний цикл
// і ніколи не завершується, тому її тип, що повертається, теж never.

// Наприклад, listen в express, оскільки підключення до сервера є
// постійне і теж має тип never.

// Будь-які спроби присвоїти значення змінної value, яка має тип never,
//  призводять до помилки компіляції.

// let value: never;

// value = 123;
// value = "hello";

// export {};

// ==============================

// Function Type

// Ми можемо описати функцію як тип. TypeScript дозволяє
// визначити типи параметрів, які функція набуває, і тип
// значення, що повертається. Це робить код більш
// надійним та зручним для читання та розуміння.

// Ось приклад типу функції у TypeScript:

// let myFunc: (firstArg: string, secondArg: number) => void;

// myFunc = (first: string, second: number) => {
//   console.log(`First: {first}, Second: ${second}`);
// };

// myFunc("Hello", 42); // Висновок: "First: Hello, Second: 42"

// export {};

// У цьому прикладі myFunc визначено як функцію, яка приймає
// два аргументи: рядок і число, і нічого не повертає (void).
// Потім ми присвоюємо функцію, що відповідає цьому типу
// функції, змінній myFunc.

// Це дуже зручно для callback, давайте винесемо опис в окремий тип.

// // Визначення типу функції, який приймає два числа та повертає число
// type CallackType = (num1: number, num2: number) => number;

// // Функція, яка приймає два числа та функцію зворотного виклику,
// // застосовує цю функцію до чисел та виводить результат
// function calc(param1: number, param2: number, callback: CallackType): void {
//   console.log("Result:", callback(param1, param2));
// }

// // Приклади використання calc з різними функціями зворотного виклику
// calc(1, 1, (num1, num2) => num1 + num2); // "Result:" 2
// calc(10, 5, (num1, num2) => num1 - num2); // "Result:" 5

// Ми можемо підвищити гнучкість. Замість того, щоб обмежувати
// тип CallbackType, який приймає рівно два числові аргументи,
// можна допустити функції, які можуть приймати будь-яку
// кількість аргументів.

// type CallbackType = (...nums: number[]) => number;

// function calc(param1: number, param2: number, callback: CallbackType): void {
//   console.log("Result:", callback(param1, param2));
// }

// calc(1, 1, (num1, num2) => num1 + num2);
// calc(10, 5, (num1, num2) => num1 - num2);

// Але не завжди буде розумно так робити. Іноді строгість — запорука порядку.

/* ======================================================================================================================
Custom Types
====================================================================================================================== */

// Custom Types, або типи даних користувача, — це потужний
// інструмент у TypeScript, що дозволяє вам визначати власні
// структури даних. Ми вже описували свої типи, але давайте
// зануримось в цю тему глибше.

// У TypeScript ви можете визначити власні типи за допомогою
// ключового слова type. Розглянемо простий приклад:

// type User = {
//   id: number;
//   name: string;
// };

// const user: User = {
//   id: 1,
//   name: 'Alice',
// };

// Тут User — це тип даних користувача, який ми визначили за
// допомогою ключового слова type. Він є структурою об'єкта
// з двома полями: id, яке є числом, і name, яке є рядком.

// Користувацькі типи можуть бути більш складними і включати
// в себе інші типи даних користувача.

// type Coordinate = [number, number];

// type UserWithCoords = {
//   id: number;
//   name: string;
//   coords: Coordinate;
// };

// const userWithCoords: UserWithCoords = {
//   id: 1,
//   name: "Alice",
//   coords: [10, 20],
// };

// export {};

// У цьому прикладі ми визначили тип Coordinate
// як кортеж з двох чисел, а потім використали
// цей тип у визначенні іншого типу, UserWithCoords.

// Давайте ускладнимо приклад ще більше. Скористаємося
// enum як сховищем ключів та опишемо для кожного тип.

// enum AnimalIds {
//   cat = "cat",
//   dog = "dog",
//   fish = "fish",
// }

// type Animal = {
//   [AnimalIds.cat]: {
//     meow: () => string;
//   };
//   [AnimalIds.dog]: {
//     bark: () => string;
//   };
//   [AnimalIds.fish]: {
//     swim: () => undefined;
//   };
// };

// // Створення об'єктів типу Animal
// let cat: Animal[AnimalIds.cat] = {
//   meow: () => "Meow! I am a cat",
// };

// let dog: Animal[AnimalIds.dog] = {
//   bark: () => "Woof! I am a dog",
// };

// let fish: Animal[AnimalIds.fish] = {
//   swim: () => undefined,
// };

// export {}

// У цьому прикладі ми створили окремі об'єкти для кожної
// тварини, визначеної у типі Animal. Кожен із цих об'єктів
// містить функцію, що відповідає його типу (meow для кішки,
// bark для собаки, swim для риби).

// Важливо зазначити, що під час створення цих об'єктів ми
// також використовували AnimalIds. У цьому контексті це може
// здатися зайвим, але уявіть ситуацію, коли подібний код
// розподілено по різних частинах вашого проєкту. У таких
// умовах, спираючись на enum, ви гарантовано оберете
// правильний тип даних. Ця конструкція не настільки поширена,
// але має право на існування і може бути корисною у певних сценаріях.

/* ======================================================================================================================
Опціональні параметри та властивості
====================================================================================================================== */

// У TypeScript ви можете зробити параметр опціональним,
// додавши символ ? після назви параметра. Це означає, що
// параметр може бути пропущений під час виклику функції.

// function greet(name?: string) {
//   if (name) {
//     return `Hello ${name}!`;
//   } else {
//     return "Hello!";
//   }
// }

// console.log(greet("Alice")); // Виводить: Hello, Alice!
// console.log(greet()); // Виводить: Hello!

// export {};

// Аналогічно у TypeScript ви можете зробити властивість
// інтерфейсу або типу опціональною, додавши символ ? після назви властивості.

// type Person = {
//   name: string;
//   age?: number; // age є опціональною властивістю
// };

// const alice: Person = { name: "Alice", age: 27 };
// const bob: Person = { name: "Bob" }; // age не вказано, це припустимо

// export {};

// У цьому прикладі age є опціональною властивістю Person.
// Це означає, що під час створення об'єкта типу Person,
// властивість age може бути пропущеною.

// ==========================

// Різниця між Type та Interface

// TypeScript надає два основних способи визначення типів
// у вашому коді: за допомогою type та interface.

// Type та interface у багатьох аспектах дуже схожі, і у
// багатьох випадках ви можете використовувати їх взаємозамінно.

// Давайте опишемо interface:

// interface Animal {
//   name: string;
// }

// Як бачимо, це дуже схоже на опис класу: ми не ставимо знак
// дорівнює(=) після Animal, а відразу починаємо описувати тип.
// Якби ми використовували тип замість інтерфейсу, це виглядало б так:

// type Animal = {
//   name: string;
// };

// Interface підтримує об'єднання через оголошення з тим самим ім'ям.
// Якщо ви визначите два interface з одним і тим же ім'ям, вони будуть "змерджені" в одне.

// interface Animal {
//   name: string;
// }

// interface Animal {
//   age: number;
// }

// let dog: Animal = {
//   name: "Fido",
//   age: 5,
// };

// export {};

// Якщо ми хочемо розширити один інтерфейс іншим, у яких
// різні імена, нам потрібно використовувати оператор extends:

// interface Dog extends Animal {
//   bark: string;
// }

// У випадку з типом нам довелося б використовувати intersection (&).

// type AnimalName = {
//   name: string;
// };

// type AnimalAge = {
//   age: number;
// };

// type Animal = AnimalName & AnimalAge;

// let dog: Animal = {
//   name: "Fido",
//   age: 5,
// };

// export {};

// Ми також можемо міксувати Interface та type,
// але результат нам доведеться зберегти як тип.

// type Cat = {
//   meow: () => string;
// };

// interface Dog {
//   bark: () => string;
// }

// type DogOrCat = Dog | Cat;
// type DogAndCat = Dog & Cat;

// export {};

// Ви могли б задатися питанням, навіщо нам потрібен Interface,
// якщо у нас вже є Type? Назва 'Interface' говорить сама за
// себе. Він являє собою якийсь 'інтерфейс', який має описувати
// структуру об'єктів, їхні методи та властивості. Інтерфейси
// переважно призначені для опису класів. Через це вони не можуть
// зберігати в собі примітивні значення, як це може робити Type,
// а також масиви та інші структури даних, які не є об'єктами.
// Ми просто не зможемо їх туди зберегти, оскільки за
// синтаксисом відразу йдуть фігурні дужки {}.

// Давайте скористаємося ним за призначенням та опишемо клас:

// interface Animal {
//   name: string;
// }

// interface Dog extends Animal {
//   bark: string;
// }

// class MyDog implements Dog {
//   name = "Fido";
//   bark = "Woof";
// }

// // Error: Property 'name' is missing in type 'OtherDog'
// class OtherDog implements Dog {
//   bark = "woof";
// }

// export {};

// За допомогою ключового слова 'implements' ми встановлюємо
// обов'язкові властивості для класу. Якщо тепер у класі ми
// пропустимо будь-яку властивість, вказану в інтерфейсі, ми
// отримаємо помилку, як це сталося в класі OtherDog.

// Ми можемо реалізовувати кілька інтерфейсів одночасно.

// interface Walkable {
//   walk(): void;
// }

// interface Eatable {
//   eat(): void;
// }

// class Animal implements Walkable, Eatable {
//   walk() {
//     console.log("The animal walks...");
//   }

//   eat() {
//     console.log("The animal eats...");
//   }
// }

// const animal = new Animal();

// export {};

// У цьому прикладі клас Animal реалізує два інтерфейси: Walkable та Eatable.

// Ще за допомогою інтерфейсу можна описати функцію.

// interface AddFunc {
//   (n1: number, n2: number): number;
// }

// let add: AddFunc;

// add = (n1:number, n2: number) => {
//   return n1 + n2;
// }

// Але, це не дуже зручно і складно виглядає,
// краще в таких випадках використовувати type.

// Докладніше ми розберемо інтерфейси і як з
// ними працювати в модулі з ООП.

/* ======================================================================================================================
Інтерфейси
====================================================================================================================== */

// Загальне поняття

// Інтерфейс — це визначення кастомного типу даних,
// але без будь-якої реалізації.

// У TypeScript інтерфейси відіграють ключову роль статичної
// типізації. Вони допомагають забезпечити узгодженість та
// чіткість структури об'єктів чи класів.

// Давайте розглянемо приклад інтерфейсу для опису типу даних Person:

// interface Person {
//   firstName: string;
//   lastName: string;
//   age?: number; // Необов'язкове поле
// }

// function greet(person: Person) {
//   console.log(`Hello, ${person.firstName} ${person.lastName}`);
// }

// const john: Person = {
//   firstName: "Jonh",
//   lastName: "Dou",
// };

// greet(john); // Виведе: "Hello, John Doe"

// У цьому прикладі ми визначили інтерфейс Person з полями
// firstName, lastName та необов'язковим полем age. Потім
// ми використали цей інтерфейс для типізації параметра
// функції greet та змінної john. Отже, ми можемо бути
// впевнені в тому, що функція greet завжди працюватиме з
// об'єктами, що мають структуру, що відповідає інтерфейсу Person.

// ============================

// Інтерфейси об'єктів

// У TypeScript ми можемо використовувати інтерфейси як тип
// даних для об'єктів. Розширимо наш приклад про літаки,
// додавши пілота. Для цього створимо інтерфейс IPerson:

// interface IPerson {
//   name: string;
//   age: number;
//   greet(phrase: string): void;
// }

// let user: IPerson;

// user = {
//   name: "Anthony",
//   age: 21,
//   // hobby: "Flying", // Помилка: Property 'hobby' does not exist on type 'IPerson'.
//   greet(phrase) {
//     console.log(phrase + " " + this.name);
//   },
// };

// user.greet("Вітання всім, я"); // Вітання всім, я Anthony

// Отже, бачимо, що створили об'єкт user типу IPerson,
// який успішно реалізує інтерфейс IPerson. І хоча цей
// користувач згодом стане нашим капітаном, зараз він просто Ентоні.

// Створення інтерфейсу відбувається за допомогою команди
// interface, після якої слідує ім'я інтерфейсу. За
// загальноприйнятою узгодженістю ім'я інтерфейсу починається
// з великої літери I, а потім слідує ім'я інтерфейсу, що
// починається з великої літери. Зустрічається також іменування
// у форматі PersonInterface, де явно вказується, що це
// інтерфейс, проте для зручності програмістів часто
// використовують більш коротку форму.

// Наразі наш інтерфейс виконує функцію типу: він визначає,
// які поля мають бути в об'єкті. Якщо спробуємо додати поле,
// якого немає в інтерфейсі, TypeScript видасть помилку.

// Насправді якщо ми використовуємо інтерфейс для об'єкта,
// мало що змінюється, якщо ми замінимо interface на type.

// Давайте спробуємо:

// type IPerson = {
//   name: string;
//   age: number;
//   greet(phrase: string): void;
// };

// let user: IPerson;

// user = {
//   name: "Anthony",
//   age: 21,
//   greet(phrase) {
//     console.log(phrase + " " + this.name);
//   },
// };

// user.greet("Вітання всім, я"); // Вітання всім, я Anthony

// І знову все працює! І все-таки є різниця між interface
// і type, особливо коли ми хочемо додати інтерфейс у клас.

// ========================

// Readonly

// Інтерфейси дозволяють використовувати модифікатор readonly.
// Цей модифікатор робить властивість лише для читання, що
// означає, що його значення можна встановити лише при створенні
// об'єкта і не можна згодом змінити.

// Давайте подивимося на приклад:

// interface ITest {
//   readonly name: string;
// }

// const person: ITest = {
//   name: "Person name",
// };

// person.name = "Another Name"; // Error: Cannot assign to 'name' because it is a read-only property

// Спроба перепризначити name призведе до помилки компіляції.
// Це гарантує, що об'єкти, що відповідають цьому інтерфейсу,
// матимуть властивість name, яку не можна змінити після їх
// створення, що забезпечує більшу надійність коду та запобігає
// випадковим змінам. Цей аспект роботи з інтерфейсами особливо
// важливий під час роботи з об'єктами, які мають залишатися
// незмінними після створення.

// =============================

// Extending Interfaces

// Однією із чудових можливостей, які надають нам інтерфейси,
// є можливість розширення. Інакше висловлюючись, один інтерфейс
// може наслідувати властивості та методи іншого інтерфейсу з
// допомогою ключового слова extends. Це особливо корисно, коли
// у вас є кілька об'єктів, які поділяють загальні властивості
// або методи, і ви хочете уникнути дублювання коду.

// Давайте розглянемо приклад. У нас є інтерфейс IPerson, який
// описує базові властивості та методи, які повинна мати кожна людина:

// interface IPerson {
//   name: string;
//   age: number;
//   greet(phrase: string): void;
// }

// interface IPilot extends IPerson {
//   flyMessage(): void;
// }

// Тепер припустимо, у нас є специфічний тип людей — пілоти.
// Вони мають усі властивості та методи звичайної людини, але
// мають додатковий метод flyMessage(). Замість того, щоб
// перевизначати всі властивості та методи з IPerson у новому
// інтерфейсі IPilot, ми можемо просто розширити IPerson:

// Тепер інтерфейс IPilot включає всі властивості та методи з
// IPerson, а також додатковий метод flyMessage(). Це значно
// спрощує організацію та підтримку нашого коду, особливо під
// час роботи з великими та складними об'єктами.

// =============================

// Інтерфейси як тип функції

// Інтерфейси можуть використовуватися не тільки для опису
// форми об'єктів, але і для визначення типів функцій.

// Раніше ми обговорювали використання типів для
// визначення функцій, як у цьому прикладі:

// type addFunc = (n1: number, n2: number) => number;

// let add: addFunc;
// add = (n1: number, n2: number) => {
//   return n1 + n2;
// };

// У цьому прикладі AddFunc визначає функцію, що приймає
// два числа та повертає число. Ми можемо використовувати
// цей тип для анотації змінних і гарантуємо, що будь-яка
// функція, яку ми присвоюємо цим змінним, відповідає цьому формату.

// Але ми можемо досягти такого самого результату з використанням
// інтерфейсів. Синтаксис трохи відрізняється, але ідея така сама:

// interface addFunc {
//   (n1: number, n2: number): number;
// }

// let add: addFunc;

// add = (n1: number, n2: number) => {
//   return n1 + n2;
// };

// У цьому випадку AddFunc визначається як інтерфейс з одним
// методом, що викликається. Це, по суті, аналогічно тому,
// що ми робили з типами, але з використанням синтаксису інтерфейсів.

// Зрештою, вибір між використанням типів або інтерфейсів часто
// зводиться до переваг стилю або конкретних вимог проєкту.
// Обидва підходи працюють однаково добре визначення типів функцій.

// ====================

// Опціональні властивості

// Інтерфейси можуть включати опціональні властивості, що
// дозволяє створити більш гнучкі та універсальні типи.
// Все, що потрібно зробити, це додати знак питання (?)
// після імені властивості у визначенні інтерфейсу.

// Візьмемо такий приклад:

// interface IPerson {
//   name?: string;
//   age: number;
// }

// Тут name є опціональною властивістю інтерфейсу IPerson.
// Це означає, що об'єкти, які відповідають цьому інтерфейсу,
// можуть містити або не містити властивості name.

// Тепер, коли ми реалізуємо цей інтерфейс, ми можемо
// позначити name як опціональну властивість.

// interface IPerson {
//   name?: string;
//   age: number;
// }

// const mango: IPerson = {
//   name: "Mango",
//   age: 2,
// };

// const poly: IPerson = {
//   age: 3,
// };

// Оскільки name — опціональна властивість, ми можемо
// її взагалі не вказувати в об’екті, і це не викличе помилку.

/* ======================================================================================================================
Advanced Types
====================================================================================================================== */
// Type Casting

// Type Casting (або Type Conversion) використовується для
// перетворення об'єкта одного типу на об'єкт іншого типу.

// TypeScript використовує два синтаксичні підходи для типового
// приведення: кутові дужки <> та оператор as.

// let someValues: unknown = "this is a string";
// let strLength1: number = (<string>someValues).length;
// let strLength2: number = (someValues as string).length;
// let strLength3: number = someValues.length;

// export {};

// У цьому прикладі ми маємо змінну someValue типу unknown, і ми
// хочемо обробити її як рядок. Ми знаємо, що це рядок, але
// TypeScript цього не знає. Тому ми використовуємо Type Casting
// для уточнення типу someValue. Якщо ми цього не зробимо, то
// отримаємо помилку, як у змінній strLength3.

// Під час роботи з HTML-елементами, ми можемо отримати проблеми.

// const input = document.getElementById("inputEmail");
// input.value = "test@test.ts";
// export {};

// Спочатку TypeScript інтерпретує його як HTMLElement, у якому
// відсутня властивість value. Але тепер нам потрібно вказати
// правильний тип. Для цього у нас є два варіанти.

// const input = <HTMLInputElement>document.getElementById("inputEmail");
// input.value = "test@test.ts";

// export {};

// І є другий, більш універсальний через as.

// const input = document.getElementById("inputEmail") as HTMLInputElement;
// input.value = "test@test.ts";

// export {};

// Таким чином, ви можете змінювати або призначати тип у процесі
//  виконання коду. Спробуємо видалити його зараз і призначити пізніше.

// const input = document.getElementById("inputEmail");
// if (input) {
//   (input as HTMLInputElement).value = "test@test.ts";
// }

// export {};

// Однак, коли використовується JSX (React), тільки оператор
// as можна використати, оскільки синтаксис <Type> може бути
// неправильно інтерпретований як JSX.

// ==============================================

// Index Properties

// Бувають ситуації, коли ми знаємо якісь поля явно,
// але деякі поля нам невідомі, а ми точно знаємо,
// якого типу вони мають бути. Для цього можна
// скористатися ось такою конструкцією:

// type indexType = {
//   [prop: string]: string;
// };

// У цьому визначенні типу, prop: string вказує, що ключі
// мають бути рядками, а string після двокрапки вказує,
// що значення мають бути рядками.

// type Person = {
//   name: string;
//   [x: string]: string;
// };

// const user: Person = {
//   name: "Alex",
//   gender: "man",
//   country: "Ukraine",
// };

// export {};

// І тепер це буде працювати. Обов'язково потрібно вказати
// name та будь-яку кількість інших полів.

// Використання індексних властивостей дозволяє вам створювати
// словники або карти, де ключі та значення мають певний тип.

// type User = {
//   id: string;
//   name: string;
//   email: string;
// };

// type Users = {
//   [id: string]: User;
// };

// let users: Users = {};

// let user: User = {
//   id: "1",
//   name: "Alex",
//   email: "alex@example.com",
// };

// users[user.id] = user;

// export {};

// У цьому прикладі ми визначили тип Users, який містить об'єкти
// типу User. Потім ми створили об'єкт users, який може містити
// невідому кількість користувачів, кожен з яких може бути доступний за його id.

/* ======================================================================================================================
Generics
====================================================================================================================== */

// Загальна концепція

// Узагальнені типи (Generics) - це один із потужних інструментів
// TypeScript, що допомагають створювати код, який можна
// використовувати повторно, зберігаючи водночас строгу типізацію.

// Основна ідея узагальнених типів (Generics) полягає в тому, що
// вони дозволяють визначити "узагальнений" тип, який потім може
// бути спеціалізований для роботи з різними іншими типами.
// Замість того, щоб визначати окремі функції для кожного можливого
// типу даних, ви можете визначити одну функцію, яка працює з
// "будь-яким" типом даних.

// Давайте спочатку постараємося розібратися в наступному: ми
// хочемо створити масив, який міститиме лише рядки та числа.
// Що ми можемо вдіяти? Наприклад, приблизно так:

// let arr[]: any = []

// Так, цей масив може містити рядки та числа, але також може
// містити все, що ми туди покладемо, від null до об'єктів.
// Але ми хочемо, щоб він містив лише рядки чи числа. Саме
// тут нам на допомогу приходять generics.

// Ми знаємо, що масив це об'єкт Array і хочемо уточнити,
// які типи до нього можуть входити:

// let arr: Array<string | number> = [];

// Ми вказали, що тип Array складатиметься з рядків та
// чисел і, тепер, якщо ми передамо туди не той тип, отримаємо помилку.

// let arr: Array<string | number> = [];

// arr = ["str", 1, true];
// export {};

// Розгляньмо ще один приклад, коли використання узагальнених
// типів стає просто необхідним. Це відбувається, коли ми
// працюємо з асинхронним кодом. Оскільки Promise може
// повернути абсолютно все, без дженерика ми ніколи не
// дізнаємось, що він повертає.

// Створимо Promise, вказавши тип.

// const promise: Promise<string> = new Promise((resolve) => {
//   setInterval(() => {
//     resolve("Done!");
//   }, 1000);
// });

// promise.then((data) => {
//   console.log(data);
// });

// export {};

// Всередині 'data' маємо тип 'string'. Якщо ми не вкажемо тип, він буде позначений як 'any'.

// ================================================

// Generic function/method

// Узагальнені функції або методи в TypeScript є способом
// створення функцій, що можуть працювати з різними типами
//  даних, зберігаючи водночас типізацію вхідних і вихідних даних.

// Давайте подивимося на приклад простої узагальненої функції:

// function identity<T>(arg: T): T {
//   return arg;
// }

// У цій функції T є узагальненим типом. Це означає, що T є
// певним типом, який буде вказаний при виклику функції.
// Функція identity приймає аргумент типу T і повертає
// значення того ж типу T.

// Ми можемо викликати цю функцію для різних типів:

// function identity<T>(arg: T): T {
//   return arg;
// }

// let output1 = identity<string>("myString");
// let output2 = identity<number>(100);

// Також TypeScript може автоматично виводити тип під час
// використання узагальнених функцій, тому ми можемо опустити явну вказівку типу:

// function identity<T>(arg: T): T {
//   return arg;
// }

// let output1 = identity("myString");
// let output2 = identity(100);

// Generics дуже корисні у роботі з колекціями, промісами
// та багатьма іншими випадками, коли функція має бути
// гнучкою за типами даних, але водночас зберігати сувору типізацію.

// Як приклад, давайте розглянемо функцію, що приймає
// масив та повертає його перший елемент:

// function firstElement<T>(arr: T[]): T {
//   return arr[0];
// }

// let numbers = [1, 2, 3, 4, 5];
// let firstNum = firstElement(numbers);

// let strings = ["a", "b", "c", "d"];
// let firstStr = firstElement(strings);

// export {};

// У цьому прикладі функція firstElement може працювати з масивами
// будь-яких типів і завжди повертає елемент того ж типу, що й
// елементи масиву. Тобто тип T буде замінений на number або
// string залежно від значень, що передаються.

// Давайте розглянемо хрестоматійний приклад – поєднання двох об'єктів.

// function merge(objA: object, objB: object) {
//   return Object.assign(objA, objB);
// }

// const merged = merge({ name: "Alice" }, { age: 28 });

// merged.name; // err
// export {};

// Ми отримали помилку на merged.name, тому що
// TypeScript просто не знає, що міститься в об'єкті.

// Звичайно, ми можемо напряму вказати через 'as' наявність ключів в об'єкті:

// const merged = merge({ name: "Alisa" }, { age: 28 }) as {
//   name: string;
//   age: number;
// };

// Але ми отримуємо дуже брудний код, який складно читати та підтримувати.
// Давайте скористаємося дженерик-типами для вирішення цієї проблеми.

// Як ми знаємо, функція теж є об'єктом, а отже ми можемо вказати для
// неї дженерик, так само як ми це робили з масивом або промісом.

// function merge<T, U>(objA: T, objB: U) {
//   return Object.assign(objA, objB);
// }

// const merged = merge({ name: "Alisa" }, { age: 28 });

// merged.name;

// export {};

// Ми передали два типи T та U, що будуть застосовані до аргументів
// функції, і тепер у нас немає помилки. Ми отримуємо об'єднаний тип.

// const merged: {
//   name: string;
// } & {
//   age: number;
// };

// Ми також можемо передавати типи під час виклику функції.

// type Person = {
//   name: string;
// };

// type AdditionFields = {
//   age: number;
// };

// function merge<T, U>(objA: T, objB: U) {
//   return Object.assign(objA, objB);
// }

// const merged = merge<Person, AdditionFields>({ name: "Alisa" }, { age: 28 });

// merged.name;

// export {};

// ========================================

// Extends

// У контексті узагальнених типів ключове слово extends
// використовується для визначення обмежень на типи, які
// можуть бути використані з узагальненим типом. Це
// дозволяє нам уточнити, які типи допустимі у наших
// узагальнених функціях чи класах.

// Повернімося до нашої попередньої функції 'merge'.
// У ній є проблема: ми можемо передавати не лише об'єкти,
// а й будь-який інший тип даних, і це не зовсім те, що ми
// хотіли б бачити.

// const merged = merge({ name: "Alice" }, "TEXT"); // {0: 'T', 1: 'E', 2: 'X', 3: 'T', name: 'Alisa'}

// Ми передали другим аргументом рядок ‘TEXT’ і у нас вийде
// дивний результат. Ми можемо обмежити тип, використовуючи extends.

// function merge<T extends object, U extends object>(objA: T, objB: U) {
//   return Object.assign(objA, objB);
// }

// const merged = merge({ name: "Alice" }, "TEXT");
// merged.name;

// export {};

// Ми зробили:

// T extends object, U extends object

// Це дає нам обмеження, що T та U мають бути об'єктами.

// Розглянемо ще один приклад. У нас є функція, що
// повертатиме довжину або рядка, або масиву. Ми
// вирішили використати для цього дженерики:

// type Length = {
//   length: number;
// };

// function getLength<T extends Length>(str: T) {
//   return str.length;
// }

// getLength("text");
// getLength([1, 2, 3]);
// getLength(100); // Errro: Argument of type 'number' is not assignable to parameter of type 'ILength'

// export {}

// Передаючи число в getLength, ми отримуємо помилку,
// оскільки у нього немає методу length.

// Ще одним прикладом використання extends може бути
// функція, що приймає масив елементів певного типу:

// function arrayLogger<T extends Array<string>>(array: T): void {
//   array.forEach((item) => console.log(item));
// }

// arrayLogger(["Hello", "World"]); // Ok
// arrayLogger([1, 2, 3]); // Error

// export {};

// У цьому випадку T extends Array<string> означає,
// що параметр функції має бути масивом рядків.

// =========================================

// keyof

// keyof — це оператор у TypeScript, що повертає типізований
// набір ключів для заданого типу. Іншими словами, він повертає
// тип, який представляє всі можливі ключі цього типу.

// Візьмемо, наприклад, наступний тип:

// type Person = {
//   name: string;
//   age: number;
//   location: string;
// };

// type PersonKeys = keyof Person; // 'name' | 'age' | 'location'

// function getPersonInfo(person: Person, key: PersonKeys) {
//   return person[key];
// }

// const john: Person = {
//   name: "John",
//   age: 25,
//   location: "NY",
// };

// console.log(getPersonInfo(john, "age")); // 25
// console.log(getPersonInfo(john, "name")); // 'John'
// console.log(getPersonInfo(john, "job")); // Error: Argument of type '"job"' is not assignable to parameter of type 'PersonKeys'.

// export {};

// У цьому прикладі getPersonInfo може приймати лише ключі,
// допустимі для Person. Якби ми спробували передати ключ,
// якого немає в Person, TypeScript видав би помилку.

// А тепер давайте застосуємо дженерики до цієї концепції з
// використанням 'keyof'. У нашій практиці, ймовірно, виникне
// потреба повертати значення з об'єкта. Але навіть якщо ви
// використовуєте дженерики, ви можете натрапити на помилку.

// function extractValue<T extends object, U>(obj: T, key: U) {
//   return obj[key]; // Type 'U' cannot be used to index type 'T'
// }

// extractValue({ name: "John" }, "name");

// export {};

// Це відбувається, оскільки TypeScript не може гарантувати,
// що вказаний ключ дійсно наявний в об'єкті. І тут ми можемо
// скористатися оператором 'keyof'. Він дозволяє уточнити,
// що певний тип існує як ключ в об'єкті.

// function extractValue<T extends object, U extends keyof T>(obj: T, key: U) {
//   return obj[key];
// }

// extractValue({ name: "John" }, "name");
// export {}

// Тут ми написали:

// T extends object, U extends keyof T

// Тобто ми скористалися 'extends' для обмеження значень 'U' ключами з об'єкта 'T'.

// ==================================================

// Generic Classes

// Узагальнені класи в TypeScript дозволяють визначити клас
// з типами, що можуть бути встановлені під час створення
// екземпляра класу. Це дозволяє створювати класи, що можуть
// працювати з різними типами даних, зберігаючи водночас сувору типізацію.

// class DataStorage<T> {
//   private data: T[] = [];

//   addItem(item: T) {
//     this.data.push(item);
//   }

//   getItems() {
//     return [...this.data];
//   }
// }

// const textStorage = new DataStorage<string>();
// textStorage.addItem("Hello");
// textStorage.addItem("World");
// console.log(textStorage.getItems()); // ['Hello', 'World']
// textStorage.addItem(1); // Error: Argument of type 'number' is not assignable to parameter of type 'string'

// const numberStorage = new DataStorage<number>();
// numberStorage.addItem(1);
// numberStorage.addItem(2);
// console.log(numberStorage.getItems()); // [1, 2]
// numberStorage.addItem("TEXT"); // Error: Argument of type 'number' is not assignable to parameter of type 'number'

// export {}

// У цьому прикладі клас "DataStorage" має узагальнений тип "T",
// який визначається під час створення екземпляра класу. В
// результаті ми отримуємо універсальний клас для зберігання
// даних, що може працювати з рядками, числами або будь-якими
// іншими типами, які ми визначимо.

// Передаючи туди значення не того типу, ми отримуємо помилку, як:

// textStorage.addItem(1); // Error: Argument of type 'number' is not assignable to parameter of type 'string'

// numberStorage.addItem('TEXT'); // Error: Argument of type 'number' is not assignable to parameter of type 'number'

// Це також корисно для створення класів, що працюють зі
// спеціалізованими типами. Наприклад, ми можемо визначити
// клас "KeyValuePair", який приймає два узагальнені типи:
//  один для ключа та один для значення.

// class KeyValuePair<TKey, TValue> {
//   constructor(private key: TKey, private value: TValue) {}

//   getKey(): TKey {
//     return this.key;
//   }

//   getValue(): TValue {
//     return this.value;
//   }
// }

// const pair1 = new KeyValuePair("name", "Alice");
// console.log(pair1.getKey()); // 'name'
// console.log(pair1.getValue()); // 'Alice'

// const pair2 = new KeyValuePair(1, true);
// console.log(pair2.getKey()); // 1
// console.log(pair2.getValue()); // true

// export {}

// Таким чином, ми можемо використовувати один і той же
//  клас, який буде працювати з різними типами.

// ===============================================

// Utility Types

// TypeScript має великий набір утилітних типів, що
// полегшують життя розробників. Ці типи забезпечують
// гнучкість у роботі з іншими типами та забезпечують
// простий та зрозумілий спосіб створення нових типів
// на основі наявних. Всі ці типи засновані на дженериках
// та пропонують додаткові можливості для роботи з типами.

// Подивитися більше типів можна в основній документації:
// https://www.typescriptlang.org/docs/handbook/utility-types.html

// ================================================

// Partial<T>;

// Утилітний тип Partial<T> створює новий тип на основі типу T,
//  але робить всі його властивості необов'язковими. Це дуже
// корисно в ситуаціях, коли ви хочете створити об'єкт,
// заснований на певному типі, але не хочете або не можете
// вказати значення всіх властивостей відразу.

// type User = {
//   id: number;
//   name: string;
//   email: string;
//   registered: boolean;
// };

// function createUser(data: Partial<User>): User {
//   // Деякі значення за замовчуванням:
//   const defaultUser: User = {
//     id: Date.now(),
//     name: "",
//     email: "",
//     registered: false,
//   };
//   // З'єднуємо дані користувача та значення за замовчуванням
//   return { ...defaultUser, ...data };
// }

// const newUser = createUser({ name: "Alice", email: "alice@example.com" });
// console.log(newUser);
// export {};

// У цьому прикладі Partial<User> дозволяє нам створювати
// користувачів, надаючи лише дані, які відомі на момент
// створення. Значення за замовчуванням використовуються для інших полів.

// ============================================

// Readonly<T>

// Утилітний тип, що робить усі властивості у типі T
// тільки для читання. Це означає, що після того, як
// об'єкт буде створений, його властивості не можна буде змінити.

// Давайте розглянемо приклад із типом User:

// type User = {
//   id: number;
//   name: string;
//   email: string;
// };

// let alice: User = {
//   id: 1,
//   name: "Alice",
//   email: "alice@example.com",
// };

// alice.name = "Bob"; // Ok

// let aliceReadonly: Readonly<User> = {
//   id: 1,
//   name: "Alice",
//   email: "alice@example.com",
// };

// aliceReadonly.name = "Bob"; // Error: Cannot assign to 'name' because it is a read-only property.

// У цьому прикладі ми можемо змінити ім'я
// користувача alice після його створення.
// Але оскільки aliceReadonly має тип
// Readonly<User>, ми отримаємо помилку компіляції.

// Пам'ятаєте, ми створювали тип кортежу? Але
// метод 'push' все одно працював. Так ось,
// використовуючи Readonly, можна створити дійсно незмінний масив.
// Тепер цей масив не можна модифікувати жодним чином.

// const arr: Readonly<string[]> = ["one", "two", "three"];
// arr.push("four"); // Error: Property 'push' does not exist on type 'readonly string[]'.

// ==============================================

// Pick<T, K>

// Pick — це утилітний тип у TypeScript, що дозволяє вам обрати
// набір властивостей з існуючого типу і створити новий тип на
// основі цих властивостей.

// Розглянемо приклад. У нас є тип User, що містить три
// властивості: id, name та email. Ми хочемо створити
// новий тип, що міститиме лише id і name.

// type User = {
//   name: string;
//   id: number;
//   email: string;
// };

// type UserBasicInfo = Pick<User, "id" | "name">;

// let userBasicIno: UserBasicInfo = {
//   id: 1,
//   name: "John Doe",
//   email: "john@example.com", // Error: Property 'email' does not exist on type 'UserBasicInfo'
// };

// Pick дуже корисний, коли ви хочете працювати тільки з
// певною підмножиною властивостей наявного типу.

// Він часто використовується для складання типів, наприклад,
// під час роботи з API, звідки може прийти безліч полів.
// Зазвичай для всіх цих полів вже існує якийсь базовий тип,
// чи то користувач, сторінка, чи документ, і з допомогою
// 'Pick' ми вибираємо потрібні для конкретного випадку поля.

// type BaseEmplotee = {
//   id: number;
//   firstName: string;
//   lastName: string;
//   position: string;
//   department: string;
//   startDate: Date;
//   // ...і багато інших полів
// };

// type BaseProject = {
//   id: number;
//   name: string;
//   budget: number;
//   deadline: Date;
//   // ...і багато інших полів
// };

// type Assignment = {
//   employee: Pick<BaseEmplotee, "id" | "firstName" | "lastName">;
//   projects: Pick<BaseProject, "id" | "name" | "deadline">[];
//   shouldNotifyEmployee?: boolean;
// };

// У цьому прикладі Assignment — це тип, що описує властивості
// для компонента або функції, що призначає співробітників
// (BaseEmployee) на проєкти (BaseProject). Для цього
// використовуються лише деякі поля з BaseEmployee та BaseProject, а не всі.

// ==========================

// Record<K, T>

// Record<K, T> — це утилітний тип, що дозволяє створювати
// типи із заздалегідь відомими властивостями. Це дуже корисно,
// коли вам потрібно створити об'єкт із певними ключами та
// значеннями, типи яких ви заздалегідь знаєте.

// Принцип роботи Record наступний: ви вказуєте набір ключів
// K і тип T, який буде присвоєно кожному з цих ключів.

// Ось базовий приклад використання Record:

// type WeekDays = "Mon" | "Tue" | "Wed" | "Thu" | "Fri";
// type Weekend = "Sat" | "Sun";

// type Day = WeekDays | Weekend;

// type DayTranslations = Record<Day, string>;

// const translations: DayTranslations = {
//   Mon: "Понеділок",
//   Tue: "Вівторок",
//   Wed: "Середа",
//   Thu: "Четвер",
//   Fri: "Пятниця",
//   Sat: "Субота",
//   Sun: "Неділя",
// };

// У цьому прикладі DayTranslations — це тип об'єкта, ключами
// якого є значення типу Day, а значеннями – рядки. Отже, ви
// отримуєте суворо типізований об'єкт перекладу, який гарантує,
// що кожен день тижня буде перекладено.

// Record часто використовується для мапінгів, перекладів та
//  інших ситуацій, коли вам потрібно створити об'єкт із
// заздалегідь відомими ключами.

// Ми можемо використовувати enum для цього. Давайте
// визначимо enum для наших ролей:

// enum UserRoles {
//   admin = "admin",
//   manager = "manager",
//   employee = "manager",
// }

// type UserRolesStatuses = Record<UserRoles, boolean>;

// const userRolesStatuses: UserRolesStatuses = {
//   [UserRoles.admin]: true,
//   [UserRoles.manager]: false,
//   [UserRoles.employee]: true, // An object literal cannot have multiple properties with the same name
// };

// Тут UserRoles — це перерахування, що визначає можливі ролі
// користувача. UserRolesStatuses — це тип, що представляє
// запис, де кожна роль користувача зіставлена з булевим
// значенням, що вказує на активацію цієї ролі.

// Розглянемо ще один приклад. Припустимо, ми маємо форму з
// типом 'InitialFormType', і ми хочемо розширити цей тип
// помилками, які можуть виникнути.

// type InitialFormType = {
//   name: string;
//   email: string;
//   password: string;
// };

// export type Form = InitialFormType & {
//   errors: Partial<Record<keyof InitialFormType, [string]>>;
// };

// Ми визначаємо тип Form, який є об'єднанням InitialFormType
// та об'єкта, що містить поле errors.

// Keyof InitialFormType отримує всі ключі з InitialFormType
// (в цьому випадку, це name, email та password), і Record
// створює новий тип, в якому кожен із цих ключів відображається
// на масив рядків. Потім Partial робить кожну властивість
// цього нового типу необов'язковою.

// ==================================================

// Omit<T, K>

// Це Pick, але навпаки. Дозволяє створити новий тип на
// основі типу T шляхом виключення набору властивостей, зазначених у K.

// type Person = {
//   name: string;
//   age: number;
//   location: string;
// };

// Ми можемо створити новий тип 'PersonWithoutLocation', використовуючи 'Omit':

// type PersonWithoutLocation = Omit<Person, "location">;

// Тепер 'PersonWithoutLocation' є таким самим типом, як і 'Person',
// але без властивості 'location'. Це може бути корисно, якщо в
// деяких контекстах ми не хочемо мати певних властивостей у наших типах.

// =====================================================

// ReturnType<T>

// Дозволяє отримати тип функції, що повертається. Для функцій
// він має використовуватися з typeof.

// Ось простий приклад:

// function greeting() {
//   return "Hello, World";
// }

// type Greeting = ReturnType<typeof greeting>; // string

// function multiply(a: number, b: number) {
//   return a * b;
// }

// type MultiplyResult = ReturnType<typeof multiply>; // number

// Давайте напишемо обгортку для функції, але повертатимемо тип з
// колбеку. Тут нам не потрібен typeof, тому що TypeScript
// автоматично виводить типи для T.

// type Callback = (...args: unknown[]) => unknown;

// function createLoggedFunction<T extends Callback>(func: T) {
//   let funcRef = func;

//   const loggedFunction = (...args: Parameters<T>) => {
//     console.log(`Function ${func.name} was called with arguments:`, args);
//     const result = funcRef(...args) as ReturnType<T>;
//     return result;
//   };

//   return loggedFunction;
// }

// Тепер loggedFunction приймає функцію як аргумент і повертає
// нову функцію, яка всередині себе викликає вихідну функцію.
// Тип вихідної функції, що повертається, зберігається завдяки
// використанню ReturnType<T>.

// =========================================================

// Parameters<T>

// Витягує типи параметрів типу функції T. Вона повертає кортеж,
// що містить типи всіх параметрів функції T у тому порядку, в
// якому вони оголошені.

// type MyFunctionType = (a: string, b: number, c: boolean) => void;
// type MyParametrsType = Parameters<MyFunctionType>;
// // Результат: [string, number, boolean]

// У цьому прикладі MyFunctionType представляє тип функції з трьома
// параметрами: a типу string, b типу number і c типу boolean. Потім
// ми використовуємо Parameters для отримання типів параметрів цієї
// функції та привласнюємо результат типу MyParametersType.
// Результатом буде тип [string, number, boolean], що представляє
// кортеж із трьох типів параметрів функції.

// Отже, утиліта Parameters дозволяє нам отримати доступ до типів
// параметрів функції у TypeScript, як ми це зробили в прикладі з ReturnType.

// ================================================================

// NonNullable<T>

// Утилітний тип, що приймає тип T та виключає з нього null та
// undefined. Цей тип корисний, коли ви хочете гарантувати, що
// значення не буде null чи undefined.

// Ось приклад використання NonNullable:

// type SomeType = string | null | undefined;

// // NonNullableType буде 'string'
// type NonNullableType = NonNullable<SomeType>;

// У цьому прикладі SomeType — це тип, який може бути або рядком, або null,
// або undefined. Під час використання NonNullable<SomeType> ми отримуємо
// тип NonNullableType, який може бути тільки рядком.
