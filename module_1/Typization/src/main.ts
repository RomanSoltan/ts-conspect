import "./style.css";

/* ======================================================================================================================
Опис простих (скалярних) типів
====================================================================================================================== */

// У базових типах ми розбиратимемо ті типи, які є в JavaScript, і почнемо зі скалярних типів. Їх називають скалярними, тому що це прості типи, що містять одне значення.

// // boolean: логічний тип даних, який може приймати значення true або false.
// let isDone: boolean = false;

// // number: числовий тип даних для цілих та дійсних чисел.
// let decimal: number = 6; // десяткові
// let float: number = 3.14; // речові або число з плаваючою крапкою
// let hex: number = 0xf00d; // шістнадцяткове
// let binary: number = 0b1010; // двійкове
// let octal: number = 0o744; // вісімкове

// // string: текстовий тип даних для символів та рядків
// let color: string = "blue";

// // null та undefined: два спеціальні типи, що відповідають значенням null і undefined відповідно.
// let empty: null = null;
// let notParam: undefined = undefined;

// // Також не обов'язково вказувати тип даних, якщо ви передаєте його явно.
// const num = 10;
// const str = "Some str";
// const bool = true;
// const empty = null;
// const notParam = undefined;

// // Давайте спробуємо передати в аргумент функції тип даних:
// function foo(num: number, str: string, bool: boolean, empty: null) {
//   // Some logic
// }

// // Також, якщо ми задаємо значення за замовчуванням у функції, тип вказувати не потрібно.
// function foo(num = 10, str = "Some str", bool = true, empty = null) {
//   // Some logic
// }

/* ======================================================================================================================
Складні типи
====================================================================================================================== */
// Object

// У JavaScript, а отже, і у TypeScript тип Object
// використовується для зберігання колекції даних
// або більш складних структур. Він є структурою
// даних, яка може містити дані різних типів.

// Існує тип даних object:

// const obj: object = {};

// const obj: {} = {};

// Як і зі скалярними типами даних, ми можемо не уточнювати, що це Object:

// let user = {
//   name: "Tom",
//   age: 30,
// };

// Однак, використання типу object не дає нам
// особливого контролю над формою цього об'єкта.

// Ми можемо використовувати більш точну анотацію,
// за допомогою типу об'єкта:

// let user: { name: string; age: number } = {
//   name: "Tom",
//   age: 30,
// };

// Тепер, якщо ми не вкажемо якусь властивість, то отримаємо помилку.

// let user: { name: string; age: number } = {
//   age: 30,
// };

// let userNameLikeNumber: { name: string; age: number } = {
//   name: 10,
//   age: 30,
// };

// export {};

// Але погодьтеся, що не дуже зручно дублювати так
// типи та описувати їх перед присвоєнням. Ми можемо
// винести тип окремо за допомогою ключового слова type:

// type User = {
//   name: string;
//   age: number;
// };

// let user: User = {
//   name: "Tom",
//   age: 30,
// };

// let userJack: User = {
//   name: 'Jack',
//   age: 25
// };

// export {}

// Тут User — це наш власний тип, який ми створили
// для представлення користувача. Ми можемо
// використовувати цей тип скрізь, і ми використали
// його для двох змінних: user та userJack.

// Крім того, ми можемо використати interface для визначення об'єкта:

// interface User {
//   name: string;
//   age: number;
// }

// let user: User = {
//   name: "Tom",
//   age: 30,
// };

// export {};

// Загалом, типи та інтерфейси дозволяють покращити
// структуру та повторне використання коду, а також
// допомагають уникнути помилок за рахунок суворої типізації.

// В цьому разі немає суттєвої різниці між type та interface, у
// майбутніх блоках ми розберемо їх докладніше.

//  ================================

// Array

// Масиви в TypeScript — це структури, які є впорядкованим
// набором елементів. Для оголошення масиву в TypeScript
// використовується конструкція з квадратними дужками []
// або загальний тип Array.

// Якщо ми хочемо вказати масив рядків, ми робимо це так:

// let arrString: string[];

// Якщо ми спробуємо передати в нього не рядковий тип
// даних, ми отримаємо помилку.

// let arrString: string[];
// arrString = ["text", 1];
// export {}

// Як бачимо, число підсвітилося як помилка.
// Давайте створимо масив чисел:

// let arrNumber: number[];

// Тепер він може містити лише числа, і будь-який
// інший тип даних буде викликати помилку.

// let arrNumber: number[];
// arrNumber = [1, 'text'];
// export {}

// Крім того, масиви в TypeScript можуть
// бути багатовимірними. Наприклад:

// let matrix: number[][] = [
//   [1, 2],
//   [3, 4],
// ];

// Масиви також можуть містити елементи різних типів. Наприклад:
// let mixed: (number | string)[] = [1, "two"];

// Ми також можемо вказати тип масиву через узагальнення (generic):
// let numbers: Array<number> = [1, 2, 3, 4, 5];

// Можна визначити масив об'єктів у TypeScript. Наприклад:

// let users: {
//   name: string;
//   age: number;
// }[] = [
//   { name: "Tom", age: 30 },
//   { name: "Jack", age: 25 },
//   { name: "Alice", age: 32 },
// ];

// Або з використанням більш зручного запису:

// type User = {
//   name: string;
//   age: number;
// };

// let users: User[] = [
//   { name: "Tom", age: 30 },
//   { name: "Jack", age: 25 },
//   { name: "Alice", age: 32 },
// ];

// Тепер якщо якесь значення об'єкта буде не того типу, ми отримаємо помилку.

// type User = {
//   name: string;
//   age: number;
// };

// let users: User[] = [{ name: "Tom", age: '30' }];

// Це демонструє всю силу суворої типізації.
// Але іноді нам це не потрібно,
// і тоді ми можемо скористатися типом даних any:

// let arrAny: any[];

// У такому масиві можна зберігати будь-що.

// let arrAny: any[];
// arrAny = [123, "text", { name: "Tom" }, [1, 2, 3]];
// export { };

// Але не варто зловживати any, інакше TypeScript швидко перетвориться на JavaScript :)

/* ======================================================================================================================
Типи для змінних та аргументів
====================================================================================================================== */
// Any

// Any — це тип даних, який використовується, коли ви
// не знаєте, який тип даних може міститися у змінній.
// Змінні з типом any дозволяють викликати будь-які
// властивості та методи без перевірок типів. Цей тип
// даних робить змінну аналогічною змінною в JavaScript,
// що дозволяє передавати в неї будь-які значення. Однак,
// варто уникати використання типу any, оскільки це обходить
// переваги суворої типізації у TypeScript.

// let notSure: any = 4;
// notSure = "maybe a string instead";
// notSure = false;
// notSure = {};

// let num: number;
// num = notSure;
// export {};

// Основною проблемою використання типу any в TypeScript є
// відсутність суворої типізації. Зберігай його у змінну, де вказано тип.

// let num: number;
// num = notSure;

// У цьому випадку TypeScript не викличе помилку на етапі компіляції,
// адже any потенційно може являти собою будь-який тип даних. Навіть
// якщо з коду зрозуміло, що notSure — це об'єкт, а не число.

// Але в яких випадках він може бути корисним? Наприклад, коли ми
// працюємо з бібліотекою на JavaScript, що може повертати різні
// типи даних, або в ситуаціях, коли конкретний тип даних не має
// значення в контексті нашого коду.

// let data: any = fetchData();

// Або візьмемо інший приклад, коли функція приймає аргумент,
// тип якого нам не відомий, і який загалом не важливий у цьому
// контексті. Це може бути, наприклад, певна колбек-функція.

// function fetchUserData(id: string, callback: (data: any) => void): void {
//   // Тут може бути якийсь запит, але ми його заповнимо самі
//   const responseData = { name: "Tom" };
//   callback(responseData);
// }

// // Використання функції:
// fetchUserData("123", (data) => {
//   console.log(data.name); // TypeScript не викличе помилку, навіть якщо поле name не існує
// });

// export {};

// Це дозволяє нам працювати з даними, не знаючи їхньої точної структури.
// Однак це також означає, що TypeScript не зможе надати нам підказки про
// те, які властивості та методи доступні для об'єкта data.

// Unknown

// Тип unknown у TypeScript багато в чому схожий на any, але він
// забезпечує більше безпеки під час роботи зі змінними. Якщо ми
// спробуємо присвоїти значення змінної типу unknown іншій змінній
// з конкретним типом без явного приведення типів, TypeScript
// видасть помилку. Це допомагає запобігти випадковому присвоєнню
// значень неправильного типу.

// let notSure: unknown = 4;
// notSure = "maybe a string instead";
// notSure = false;

// let num: number;
// num = notSure;
// export {};

// Як бачимо, нам не вдалося зберегти значення
// змінної notSure в змінну num.

// Тип unknown підходить для сценаріїв, коли ви
// не знаєте точного типу даних, але все ж таки
// хочете підтримувати сувору перевірку типів.
// Змінні цього типу слід перевіряти перед їх використанням.

// Візьмемо для прикладу таку ситуацію: Ви отримуєте
// дані з API та не знаєте їхнього точного формату.
// У цьому випадку вам потрібно буде провести уточнення типів.

// function fetchUserData() {
//   return "Tom";
// }

// let userData: unknown = fetchUserData(); // fetchUserData повертає невідомі дані
// if (typeof userData === "string") {
//   console.log(userData.toUpperCase()); // OK, тепер ми знаємо, що це рядок
// }

// Отже, ми можемо бути впевнені, що обробляємо дані правильного типу.

// Tuple

// Кортеж, особливо популярний у мовах програмування як Python, це
// незмінний масив. У TypeScript це тип даних, що дозволяє визначити
// масив з фіксованою кількістю елементів, типи яких відомі, але не
// обов'язково повинні бути однаковими.

// Він створюється як масив, але замість значень ми передаємо
// типи даних, наприклад, [string, number].

// let tupleType: [string, boolean];
// tupleType = ["hello", true]; // OK
// tupleType = [true, "hello"]; // Error. Неправильні типи
// tupleType = ["hello", true, true]; // Error. Більше значень ніж у tuple

// export {};

// Кортежі зручні, коли нам потрібно зберегти в масив
// фіксовані значення, наприклад, день, місяць та рік.

// let date: [number, number, number];
// date = [7, 11, 2023]; // OK

// Але є нюанс: якщо ми додамо елемент у кортеж
// через метод push, то TypeScript не заперечуватиме,
// він не відстежує реальний вміст масиву.

// let fixed: [string, number];
// fixed = ["Text", 10];
// fixed.push("Add this text");
// export {};

// Як ми бачимо, компілятор не зміг розібратися і видати помилку.

// Однак, TypeScript надає гнучкі можливості для роботи з
// кортежами, включно з використанням оператора розширення
// (...) для створення кортежів змінної довжини.

// let tuple: [string, ...number[]];
// tuple = ["hello", 42, 100, 200];

// У цьому випадку перший елемент
// кортежу має бути рядком, проте всі наступні — числами.

// Enum

// Ця структура настільки широко використовується, що в
// TypeScript вирішили додати її як тип даних. Цей тип
//  називається enum і, згідно з хорошими практиками
// програмування, імена змінних цього типу мають починатися з великої літери.

// enum Role {
//   ADMIN,
//   USER,
// }

// Розглянемо застосування на прикладі користувача, який має певні права.

// enum Role {
//   ADMIN,
//   USER,
// }

// const person = {
//   role: Role.ADMIN,
// };

// if (person.role === Role.ADMIN) {
//   console.log("Role", Role.ADMIN); // Role:  0
//   console.log(Role[Role.ADMIN]); // значення enum // "ADMIN"
// }

// export {};

// Enum являє собою набір констант, що робить код більш
//  зрозумілим. Як ми бачили у минулому прикладі,
//  значеннями enum зазвичай є числа, проте ми можемо задати свої значення.

// enum UserStatus {
//   Active = "ACTIVE",
//   Inactive = "INACTIVE",
//   Banned = "BANNED",
// }

// let status: UserStatus = UserStatus.Active;

// Крім того, ви можете використовувати enum для
// угруповання взаємопов'язаних значень, що може
// бути корисним для спрощення коду та покращення читабельності:

// enum HttpCodes {
//   Ok = 200,
//   BadRequest = 400,
//   Unauthorized = 401,
// }

// function respond(status: HttpCodes) {
//   // handle response
// }

// respond(HttpCodes.Ok);
// export {};

// Коли ми будемо створювати свої типи, детальніше розберемо,
// як enum може допомогти нам у цьому процесі.

// Існує ще така конструкція, як const enum. На відміну від
// звичайного enum, const enum видаляється під час транспіляції
// та не створює додаткового об'єкта в JavaScript.

// Значення const enum вставляють у місце використання у вигляді
// літералів. Це може допомогти покращити продуктивність.

// const enum HttpCodes {
//   Ok = 200,
//   BadRequest = 400,
//   Unauthorized = 401,
// }

// const status = HttpCodes.Ok;

// Після компіляції у JavaScript отримаємо наступний код:

// const status = 200;

// Як видно з прикладу, const enum видаляється зі
// скомпільованого коду і його значення прямо
// вставляється в код. У цьому випадку HttpCodes.
// OK замінився на 200. Це і є ключовою відмінністю
//  const enum від звичайного enum.

// Однак існує одне обмеження використання const enum:
// їх не можна використовувати у виразах, які вимагають
// виконання під час виконання. Це пов'язане з тим, що
// вони замінюються на їхнє значення під час компіляції.

// const enum Test {
//   A = 1,
//   B = 2,
// }

// for (let item in Test) {
//   console.log(item);
// }

// export {};

// ==================

// Union Type

// Union Type у TypeScript дозволяє вказати, що
// значенням може бути один із кількох типів. Це
// дуже зручно, коли хочемо визначити змінну,
// яка може приймати різні типи даних. Типи
// перераховуються через вертикальну риску |

// let mixedType: string | number | boolean;

// Давайте подивимося, як це працює:

// let mixedType: string | number | boolean;

// mixedType = "string"; // Ok
// mixedType = 10; // Ok
// mixedType = true; // Ok
// mixedType = {}; // Error: Type '{}' is not assignable to type 'string | number | boolean'.

// export {};

// Union Type можна також використовувати для аргументів
// функцій. Давайте створимо функцію, яка об'єднує рядки або складає числа.

// function combine(param1: number | string, param2: number | string) {
//   return param1 + param2;
// }
// export {}

// Ми отримуємо помилку, тому що TypeScript просто не знає, рядок там чи число.

// Давайте перевіримо типи у функції.

// function combine(param1: number | string, param2: number | string) {
//   if (typeof param1 === "number" && typeof param2 === "number") {
//     return param1 + param2;
//   } else {
//     return param1.toString() + param2.toString();
//   }
// }
// export {};

// Тепер ми можемо передавати у функцію або числа, або рядки.

// Union Type працює не лише з базовими типами, а й з об'єктами:

// type Dog = {
//   legs: 4;
//   bark: () => void;
// };

// type Fish = {
//   fins: 2;
//   swim: () => void;
// };

// let pet: Dog | Fish;

// У цьому прикладі змінна pet може бути або
// об'єктом типу Dog, або об'єктом типу Fish.

// Однак існує важливе обмеження: коли ми працюємо
// зі змінною Union Type, ми можемо використовувати
// лише ті властивості та методи, які існують у всіх
// типів цього об'єднання. У прикладі вище ми не
// можемо викликати pet.bark(), якщо pet є типом Fish.
// Нам доведеться перевіряти, чи існує цей метод.

// type Dog = {
//   legs: 4;
//   bark: () => void;
// };

// type Fish = {
//   fins: 2;
//   swim: () => void;
// };

// let pet: Dog | Fish;

// // type guard function
// function isDog(pet: Dog | Fish): pet is Dog {
//   return "bark" in pet;
// }

// // Перевіряємо, чи є наш вихованець собакою перед тим, як використовувати метод bark
// if (isDog(pet)) {
//   pet.bark(); // OK, тепер TypeScript знає, що pet - це Dog
// } else {
//   pet.swim(); // TypeScript знає, що якщо pet не Dog, то це має бути Fish
// }

// export {};

// Дуже часто розробники вважають за краще використовувати
// Union Type замість enum для перерахування всіх допустимих
// значень. Це особливо зручно робити у зв'язці з Literal Type.

// =================================

// Intersection Type

// Intersection type є способом об'єднання декількох типів в один.
// Це дозволяє створювати складні типи, комбінуючи прості.
// У TypeScript можна використовувати символ & для створення типу intersection.

// type Employee = {
//   name: string;
//   id: number;
// };

// type Manager = {
//   employees: Employee[];
// };

// type CEO = Employee & Manager;

// const ceo: CEO = {
//   name: "Alice",
//   id: 1,
//   employees: [
//     {
//       name: "Bob",
//       id: 2,
//     },
//   ],
// };

// export {};

// У цьому прикладі CEO є intersection тип Employee і Manager.
//  Це означає, що об'єкт типу CEO повинен містити всі властивості,
// визначені в Employee та Manager.

// ==================================

// Literal Type

// Literal Type — це тип, що набуває конкретного значення.
// З ним ви можете визначити тип змінної так,
// щоб він набував лише певних значень.

// type OneOrTwo = 1 | 2;
// let value: OneOrTwo;
// value = 1; // Ok
// value = 2; // Ok
// value = 3; // Error: Type '3' is not assignable to type 'OneOrTwo'.

// type YesOrNo = "yes" | "no";
// let answer: YesOrNo;
// answer = "yes"; // Ok
// answer = "no"; // Ok
// answer = "maybe"; // Error: Type '"maybe"' is not assignable to type 'YesOrNo'.

// export {};

// Тут OneOrTwo може набувати лише значення 1 або 2,
// YesOrNo може набувати тільки значення "yes" або "no".

// Але давайте розглянемо якийсь бойовий приклад.
// Припустимо, ми маємо функцію, що приймає рядок як
// аргумент і повертає стилі для кнопки в залежності
// від переданого значення.

// type ButtonSize = "small" | "medium" | "large";

// function getButtonSize(size: ButtonSize) {
//   switch (size) {
//     case "small":
//       return { fontSize: "10px", padding: "5px" };
//     case "medium":
//       return { fontSize: "14px", padding: "10px" };
//     case "large":
//       return { fontSize: "18px", padding: "15px" };
//     default:
//       return { fontSize: "14px", padding: "10px" };
//   }
// }

// let myButtonStyle = getButtonSize("medium"); // OK
// myButtonStyle = getButtonSize("extra-large"); // Error: Argument of type '"extra-large"' is not assignable to parameter of type 'ButtonSize'.

// export {};

// Тут, якщо ми спробуємо викликати функцію getButtonStyle
// з аргументом "extra-large", TypeScript видасть помилку
// на етапі компіляції, оскільки "extra-large" не є
// допустимим значенням для ButtonSize.

/* ======================================================================================================================
Типи для методів та функцій
====================================================================================================================== */
// Return Type

// Return type — це тип даних, який функція повертає під
// час її виклику. TypeScript дозволяє вказувати тип значення,
// що повертається для функцій, що допомагає зробити ваш код
// більш зрозумілим і безпечним.

// function greet(): string {
//   return "Hello world";
// }

// let result = greet();

// Розглянемо цей приклад. Тут функція greet має тип значення,
//  що повертається string. Це означає, що ми гарантуємо, що
// ця функція завжди буде повертати рядок, але так само ми і
// контролюємо себе, якщо ми спробуємо змінити цю функцію так,
// щоб вона повертала число, TypeScript видасть помилку,
// контролюючи тим самим нас від ненавмисних змін типу.

// function greet(): string {
//   return 100; // Error: Type 'number' is not assignable to type 'string'
// }

// let result = greet();

// export {};

// Ми отримали помилку, оскільки реальний тип значення,
// що повертається, не збігається з тим, який був оголошений у функції.

// Для стрілочних функцій схожий синтаксис.

// const greet = (): string => {
//   return "Hello world";
// };

// let result = greet();

// Тут greet — це стрілочна функція, яка повертає рядок.
// Ми визначаємо тип значення, що повертається (string)
// після списку аргументів і перед стрілкою (=>).

// Давайте розглянемо ситуацію, де ми хочемо написати функцію,
// що отримує список користувачів та повертає імена цих
// користувачів у вигляді рядка. Ось як ми можемо типізувати таку функцію:

// type User = {
//   id: number;
//   name: string;
// };

// const getUserNames = (users: User[]): string[] => {
//   return users.map((user) => user.name);
// };

// const users: User[] = [
//   { id: 1, name: "Alice" },
//   { id: 2, name: "Bob" },
//   { id: 3, name: "Charlie" },
// ];

// let result = getUserNames(users);
// console.log(result); // ['Alice', 'Bob', 'Charlie']

// export {};

// У цьому прикладі функція getUserNames приймає масив
// об'єктів типу User та повертає масив рядків.

// Вказування типу значення, що повертається — це не
// тільки зручний спосіб документування функцій, але й
// важливий інструмент контролю коректності вашого коду.
// Він дозволяє компілятору TypeScript перевірити, чи
// функція дійсно повертає те, що ви припускали, і
// видати помилку, якщо це не так.

// Важливо також зазначити, що TypeScript здатний
// автоматично визначати типи значень функцій, що
// повертаються, на основі їх реалізації. Так, якщо
// ви не вказали тип значення, що повертається явно,
// але ваша функція повертає, наприклад, рядок,
// TypeScript автоматично присвоїть цій функції
// тип значення, що повертається string.

// function greet() {
//   return "Hello world";
// }

// let result: string = greet();

// export {};

// ======================================================

// Void

// Тип void у TypeScript використовується для позначення
// відсутності будь-якого типу взагалі, і зазвичай використовується
// як тип функцій, що повертається, в якому функції не повертають значення.

// Таких функцій у коді багато, давайте розглянемо на прикладі:

// function logMessage(message: string): void {
//   console.log(message);
// }

// logMessage("Hello world");

// export {};

// У цьому прикладі функція logMessage приймає один
// параметр — message типу string і нічого не повертає,
// тому тип, що повертається — void.

// Тип void часто використовується в callback-функціях
// або функціях зворотного виклику, де ви хочете бути
// впевнені, що функція не повертає значення, і тому не
// важливо, що повертає функція зворотного виклику.

// function doSomething(callback: () => void) {
//   callback();
// }

// doSomething(() => {
//   console.log("Callack function");
// });

// export {};

// У цьому прикладі функція doSomething приймає функцію
// зворотного виклику callback, що не повертає жодного значення.

// ==============================

// Never

// Це коли функція ніколи не закінчується та нічого не повертає.
// Часто тип never використовується для функцій, які завжди викидають
// вийняток або у нескінченних циклах.

// Ось деякі приклади його використання:

// // Функція, яка завжди викидає помилку
// function throwError(message: string): never {
//   throw new Error(message);
// }

// // Функція з нескінченним циклом
// function infiniteLoop(): never {
//   while (true) {}
// }

// export {};

// У першому прикладі функція throwError викидає помилку
// і ніколи не повертає значення, тому тип, що повертається — never.

// У другому прикладі функція infiniteLoop входить у нескінченний цикл
// і ніколи не завершується, тому її тип, що повертається, теж never.

// Наприклад, listen в express, оскільки підключення до сервера є
// постійне і теж має тип never.

// Будь-які спроби присвоїти значення змінної value, яка має тип never,
//  призводять до помилки компіляції.

// let value: never;

// value = 123;
// value = "hello";

// export {};

// ==============================

// Function Type

// Ми можемо описати функцію як тип. TypeScript дозволяє
// визначити типи параметрів, які функція набуває, і тип
// значення, що повертається. Це робить код більш
// надійним та зручним для читання та розуміння.

// Ось приклад типу функції у TypeScript:

// let myFunc: (firstArg: string, secondArg: number) => void;

// myFunc = (first: string, second: number) => {
//   console.log(`First: {first}, Second: ${second}`);
// };

// myFunc("Hello", 42); // Висновок: "First: Hello, Second: 42"

// export {};

// У цьому прикладі myFunc визначено як функцію, яка приймає
// два аргументи: рядок і число, і нічого не повертає (void).
// Потім ми присвоюємо функцію, що відповідає цьому типу
// функції, змінній myFunc.

// Це дуже зручно для callback, давайте винесемо опис в окремий тип.

// // Визначення типу функції, який приймає два числа та повертає число
// type CallackType = (num1: number, num2: number) => number;

// // Функція, яка приймає два числа та функцію зворотного виклику,
// // застосовує цю функцію до чисел та виводить результат
// function calc(param1: number, param2: number, callback: CallackType): void {
//   console.log("Result:", callback(param1, param2));
// }

// // Приклади використання calc з різними функціями зворотного виклику
// calc(1, 1, (num1, num2) => num1 + num2); // "Result:" 2
// calc(10, 5, (num1, num2) => num1 - num2); // "Result:" 5

// Ми можемо підвищити гнучкість. Замість того, щоб обмежувати
// тип CallbackType, який приймає рівно два числові аргументи,
// можна допустити функції, які можуть приймати будь-яку
// кількість аргументів.

// type CallbackType = (...nums: number[]) => number;

// function calc(param1: number, param2: number, callback: CallbackType): void {
//   console.log("Result:", callback(param1, param2));
// }

// calc(1, 1, (num1, num2) => num1 + num2);
// calc(10, 5, (num1, num2) => num1 - num2);

// Але не завжди буде розумно так робити. Іноді строгість — запорука порядку.

/* ======================================================================================================================
Custom Types
====================================================================================================================== */

// Custom Types, або типи даних користувача, — це потужний
// інструмент у TypeScript, що дозволяє вам визначати власні
// структури даних. Ми вже описували свої типи, але давайте
// зануримось в цю тему глибше.

// У TypeScript ви можете визначити власні типи за допомогою
// ключового слова type. Розглянемо простий приклад:

// type User = {
//   id: number;
//   name: string;
// };

// const user: User = {
//   id: 1,
//   name: 'Alice',
// };

// Тут User — це тип даних користувача, який ми визначили за
// допомогою ключового слова type. Він є структурою об'єкта
// з двома полями: id, яке є числом, і name, яке є рядком.

// Користувацькі типи можуть бути більш складними і включати
// в себе інші типи даних користувача.

// type Coordinate = [number, number];

// type UserWithCoords = {
//   id: number;
//   name: string;
//   coords: Coordinate;
// };

// const userWithCoords: UserWithCoords = {
//   id: 1,
//   name: "Alice",
//   coords: [10, 20],
// };

// export {};

// У цьому прикладі ми визначили тип Coordinate
// як кортеж з двох чисел, а потім використали
// цей тип у визначенні іншого типу, UserWithCoords.

// Давайте ускладнимо приклад ще більше. Скористаємося
// enum як сховищем ключів та опишемо для кожного тип.

// enum AnimalIds {
//   cat = "cat",
//   dog = "dog",
//   fish = "fish",
// }

// type Animal = {
//   [AnimalIds.cat]: {
//     meow: () => string;
//   };
//   [AnimalIds.dog]: {
//     bark: () => string;
//   };
//   [AnimalIds.fish]: {
//     swim: () => undefined;
//   };
// };

// // Створення об'єктів типу Animal
// let cat: Animal[AnimalIds.cat] = {
//   meow: () => "Meow! I am a cat",
// };

// let dog: Animal[AnimalIds.dog] = {
//   bark: () => "Woof! I am a dog",
// };

// let fish: Animal[AnimalIds.fish] = {
//   swim: () => undefined,
// };

// export {}

// У цьому прикладі ми створили окремі об'єкти для кожної
// тварини, визначеної у типі Animal. Кожен із цих об'єктів
// містить функцію, що відповідає його типу (meow для кішки,
// bark для собаки, swim для риби).

// Важливо зазначити, що під час створення цих об'єктів ми
// також використовували AnimalIds. У цьому контексті це може
// здатися зайвим, але уявіть ситуацію, коли подібний код
// розподілено по різних частинах вашого проєкту. У таких
// умовах, спираючись на enum, ви гарантовано оберете
// правильний тип даних. Ця конструкція не настільки поширена,
// але має право на існування і може бути корисною у певних сценаріях.

/* ======================================================================================================================
Опціональні параметри та властивості
====================================================================================================================== */

// У TypeScript ви можете зробити параметр опціональним,
// додавши символ ? після назви параметра. Це означає, що
// параметр може бути пропущений під час виклику функції.

// function greet(name?: string) {
//   if (name) {
//     return `Hello ${name}!`;
//   } else {
//     return "Hello!";
//   }
// }

// console.log(greet("Alice")); // Виводить: Hello, Alice!
// console.log(greet()); // Виводить: Hello!

// export {};

// Аналогічно у TypeScript ви можете зробити властивість
// інтерфейсу або типу опціональною, додавши символ ? після назви властивості.

// type Person = {
//   name: string;
//   age?: number; // age є опціональною властивістю
// };

// const alice: Person = { name: "Alice", age: 27 };
// const bob: Person = { name: "Bob" }; // age не вказано, це припустимо

// export {};

// У цьому прикладі age є опціональною властивістю Person.
// Це означає, що під час створення об'єкта типу Person,
// властивість age може бути пропущеною.

// ==========================

// Різниця між Type та Interface

// TypeScript надає два основних способи визначення типів
// у вашому коді: за допомогою type та interface.

// Type та interface у багатьох аспектах дуже схожі, і у
// багатьох випадках ви можете використовувати їх взаємозамінно.

// Давайте опишемо interface:

// interface Animal {
//   name: string;
// }

// Як бачимо, це дуже схоже на опис класу: ми не ставимо знак
// дорівнює(=) після Animal, а відразу починаємо описувати тип.
// Якби ми використовували тип замість інтерфейсу, це виглядало б так:

// type Animal = {
//   name: string;
// };

// Interface підтримує об'єднання через оголошення з тим самим ім'ям.
// Якщо ви визначите два interface з одним і тим же ім'ям, вони будуть "змерджені" в одне.

// interface Animal {
//   name: string;
// }

// interface Animal {
//   age: number;
// }

// let dog: Animal = {
//   name: "Fido",
//   age: 5,
// };

// export {};

// Якщо ми хочемо розширити один інтерфейс іншим, у яких
// різні імена, нам потрібно використовувати оператор extends:

// interface Dog extends Animal {
//   bark: string;
// }

// У випадку з типом нам довелося б використовувати intersection (&).

// type AnimalName = {
//   name: string;
// };

// type AnimalAge = {
//   age: number;
// };

// type Animal = AnimalName & AnimalAge;

// let dog: Animal = {
//   name: "Fido",
//   age: 5,
// };

// export {};

// Ми також можемо міксувати Interface та type,
// але результат нам доведеться зберегти як тип.

// type Cat = {
//   meow: () => string;
// };

// interface Dog {
//   bark: () => string;
// }

// type DogOrCat = Dog | Cat;
// type DogAndCat = Dog & Cat;

// export {};

// Ви могли б задатися питанням, навіщо нам потрібен Interface,
// якщо у нас вже є Type? Назва 'Interface' говорить сама за
// себе. Він являє собою якийсь 'інтерфейс', який має описувати
// структуру об'єктів, їхні методи та властивості. Інтерфейси
// переважно призначені для опису класів. Через це вони не можуть
// зберігати в собі примітивні значення, як це може робити Type,
// а також масиви та інші структури даних, які не є об'єктами.
// Ми просто не зможемо їх туди зберегти, оскільки за
// синтаксисом відразу йдуть фігурні дужки {}.

// Давайте скористаємося ним за призначенням та опишемо клас:

// interface Animal {
//   name: string;
// }

// interface Dog extends Animal {
//   bark: string;
// }

// class MyDog implements Dog {
//   name = "Fido";
//   bark = "Woof";
// }

// // Error: Property 'name' is missing in type 'OtherDog'
// class OtherDog implements Dog {
//   bark = "woof";
// }

// export {};

// За допомогою ключового слова 'implements' ми встановлюємо
// обов'язкові властивості для класу. Якщо тепер у класі ми
// пропустимо будь-яку властивість, вказану в інтерфейсі, ми
// отримаємо помилку, як це сталося в класі OtherDog.

// Ми можемо реалізовувати кілька інтерфейсів одночасно.

// interface Walkable {
//   walk(): void;
// }

// interface Eatable {
//   eat(): void;
// }

// class Animal implements Walkable, Eatable {
//   walk() {
//     console.log("The animal walks...");
//   }

//   eat() {
//     console.log("The animal eats...");
//   }
// }

// const animal = new Animal();

// export {};

// У цьому прикладі клас Animal реалізує два інтерфейси: Walkable та Eatable.

// Ще за допомогою інтерфейсу можна описати функцію.

// interface AddFunc {
//   (n1: number, n2: number): number;
// }

// let add: AddFunc;

// add = (n1:number, n2: number) => {
//   return n1 + n2;
// }

// Але, це не дуже зручно і складно виглядає,
// краще в таких випадках використовувати type.

// Докладніше ми розберемо інтерфейси і як з
// ними працювати в модулі з ООП.
