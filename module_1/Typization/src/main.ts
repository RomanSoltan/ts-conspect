import "./style.css";

/* ======================================================================================================================
Опис простих (скалярних) типів
====================================================================================================================== */

// У базових типах ми розбиратимемо ті типи, які є в JavaScript, і почнемо зі скалярних типів. Їх називають скалярними, тому що це прості типи, що містять одне значення.

// // boolean: логічний тип даних, який може приймати значення true або false.
// let isDone: boolean = false;

// // number: числовий тип даних для цілих та дійсних чисел.
// let decimal: number = 6; // десяткові
// let float: number = 3.14; // речові або число з плаваючою крапкою
// let hex: number = 0xf00d; // шістнадцяткове
// let binary: number = 0b1010; // двійкове
// let octal: number = 0o744; // вісімкове

// // string: текстовий тип даних для символів та рядків
// let color: string = "blue";

// // null та undefined: два спеціальні типи, що відповідають значенням null і undefined відповідно.
// let empty: null = null;
// let notParam: undefined = undefined;

// // Також не обов'язково вказувати тип даних, якщо ви передаєте його явно.
// const num = 10;
// const str = "Some str";
// const bool = true;
// const empty = null;
// const notParam = undefined;

// // Давайте спробуємо передати в аргумент функції тип даних:
// function foo(num: number, str: string, bool: boolean, empty: null) {
//   // Some logic
// }

// // Також, якщо ми задаємо значення за замовчуванням у функції, тип вказувати не потрібно.
// function foo(num = 10, str = "Some str", bool = true, empty = null) {
//   // Some logic
// }

/* ======================================================================================================================
Складні типи
====================================================================================================================== */
// Object

// У JavaScript, а отже, і у TypeScript тип Object
// використовується для зберігання колекції даних
// або більш складних структур. Він є структурою
// даних, яка може містити дані різних типів.

// Існує тип даних object:

// const obj: object = {};

// const obj: {} = {};

// Як і зі скалярними типами даних, ми можемо не уточнювати, що це Object:

// let user = {
//   name: "Tom",
//   age: 30,
// };

// Однак, використання типу object не дає нам
// особливого контролю над формою цього об'єкта.

// Ми можемо використовувати більш точну анотацію,
// за допомогою типу об'єкта:

// let user: { name: string; age: number } = {
//   name: "Tom",
//   age: 30,
// };

// Тепер, якщо ми не вкажемо якусь властивість, то отримаємо помилку.

// let user: { name: string; age: number } = {
//   age: 30,
// };

// let userNameLikeNumber: { name: string; age: number } = {
//   name: 10,
//   age: 30,
// };

// export {};

// Але погодьтеся, що не дуже зручно дублювати так
// типи та описувати їх перед присвоєнням. Ми можемо
// винести тип окремо за допомогою ключового слова type:

// type User = {
//   name: string;
//   age: number;
// };

// let user: User = {
//   name: "Tom",
//   age: 30,
// };

// let userJack: User = {
//   name: 'Jack',
//   age: 25
// };

// export {}

// Тут User — це наш власний тип, який ми створили
// для представлення користувача. Ми можемо
// використовувати цей тип скрізь, і ми використали
// його для двох змінних: user та userJack.

// Крім того, ми можемо використати interface для визначення об'єкта:

// interface User {
//   name: string;
//   age: number;
// }

// let user: User = {
//   name: "Tom",
//   age: 30,
// };

// export {};

// Загалом, типи та інтерфейси дозволяють покращити
// структуру та повторне використання коду, а також
// допомагають уникнути помилок за рахунок суворої типізації.

// В цьому разі немає суттєвої різниці між type та interface, у
// майбутніх блоках ми розберемо їх докладніше.

//  ================================

// Array

// Масиви в TypeScript — це структури, які є впорядкованим
// набором елементів. Для оголошення масиву в TypeScript
// використовується конструкція з квадратними дужками []
// або загальний тип Array.

// Якщо ми хочемо вказати масив рядків, ми робимо це так:

// let arrString: string[];

// Якщо ми спробуємо передати в нього не рядковий тип
// даних, ми отримаємо помилку.

// let arrString: string[];
// arrString = ["text", 1];
// export {}

// Як бачимо, число підсвітилося як помилка.
// Давайте створимо масив чисел:

// let arrNumber: number[];

// Тепер він може містити лише числа, і будь-який
// інший тип даних буде викликати помилку.

// let arrNumber: number[];
// arrNumber = [1, 'text'];
// export {}

// Крім того, масиви в TypeScript можуть
// бути багатовимірними. Наприклад:

// let matrix: number[][] = [
//   [1, 2],
//   [3, 4],
// ];

// Масиви також можуть містити елементи різних типів. Наприклад:
// let mixed: (number | string)[] = [1, "two"];

// Ми також можемо вказати тип масиву через узагальнення (generic):
// let numbers: Array<number> = [1, 2, 3, 4, 5];

// Можна визначити масив об'єктів у TypeScript. Наприклад:

// let users: {
//   name: string;
//   age: number;
// }[] = [
//   { name: "Tom", age: 30 },
//   { name: "Jack", age: 25 },
//   { name: "Alice", age: 32 },
// ];

// Або з використанням більш зручного запису:

// type User = {
//   name: string;
//   age: number;
// };

// let users: User[] = [
//   { name: "Tom", age: 30 },
//   { name: "Jack", age: 25 },
//   { name: "Alice", age: 32 },
// ];

// Тепер якщо якесь значення об'єкта буде не того типу, ми отримаємо помилку.

// type User = {
//   name: string;
//   age: number;
// };

// let users: User[] = [{ name: "Tom", age: '30' }];

// Це демонструє всю силу суворої типізації.
// Але іноді нам це не потрібно,
// і тоді ми можемо скористатися типом даних any:

// let arrAny: any[];

// У такому масиві можна зберігати будь-що.

// let arrAny: any[];
// arrAny = [123, "text", { name: "Tom" }, [1, 2, 3]];
// export { };

// Але не варто зловживати any, інакше TypeScript швидко перетвориться на JavaScript :)
