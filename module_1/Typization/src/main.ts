import "./style.css";

/* ======================================================================================================================
Опис простих (скалярних) типів
====================================================================================================================== */

// У базових типах ми розбиратимемо ті типи, які є в JavaScript, і почнемо зі скалярних типів. Їх називають скалярними, тому що це прості типи, що містять одне значення.

// // boolean: логічний тип даних, який може приймати значення true або false.
// let isDone: boolean = false;

// // number: числовий тип даних для цілих та дійсних чисел.
// let decimal: number = 6; // десяткові
// let float: number = 3.14; // речові або число з плаваючою крапкою
// let hex: number = 0xf00d; // шістнадцяткове
// let binary: number = 0b1010; // двійкове
// let octal: number = 0o744; // вісімкове

// // string: текстовий тип даних для символів та рядків
// let color: string = "blue";

// // null та undefined: два спеціальні типи, що відповідають значенням null і undefined відповідно.
// let empty: null = null;
// let notParam: undefined = undefined;

// // Також не обов'язково вказувати тип даних, якщо ви передаєте його явно.
// const num = 10;
// const str = "Some str";
// const bool = true;
// const empty = null;
// const notParam = undefined;

// // Давайте спробуємо передати в аргумент функції тип даних:
// function foo(num: number, str: string, bool: boolean, empty: null) {
//   // Some logic
// }

// // Також, якщо ми задаємо значення за замовчуванням у функції, тип вказувати не потрібно.
// function foo(num = 10, str = "Some str", bool = true, empty = null) {
//   // Some logic
// }

/* ======================================================================================================================
Складні типи
====================================================================================================================== */
// Object

// У JavaScript, а отже, і у TypeScript тип Object
// використовується для зберігання колекції даних
// або більш складних структур. Він є структурою
// даних, яка може містити дані різних типів.

// Існує тип даних object:

// const obj: object = {};

// const obj: {} = {};

// Як і зі скалярними типами даних, ми можемо не уточнювати, що це Object:

// let user = {
//   name: "Tom",
//   age: 30,
// };

// Однак, використання типу object не дає нам
// особливого контролю над формою цього об'єкта.

// Ми можемо використовувати більш точну анотацію,
// за допомогою типу об'єкта:

// let user: { name: string; age: number } = {
//   name: "Tom",
//   age: 30,
// };

// Тепер, якщо ми не вкажемо якусь властивість, то отримаємо помилку.

// let user: { name: string; age: number } = {
//   age: 30,
// };

// let userNameLikeNumber: { name: string; age: number } = {
//   name: 10,
//   age: 30,
// };

// export {};

// Але погодьтеся, що не дуже зручно дублювати так
// типи та описувати їх перед присвоєнням. Ми можемо
// винести тип окремо за допомогою ключового слова type:

// type User = {
//   name: string;
//   age: number;
// };

// let user: User = {
//   name: "Tom",
//   age: 30,
// };

// let userJack: User = {
//   name: 'Jack',
//   age: 25
// };

// export {}

// Тут User — це наш власний тип, який ми створили
// для представлення користувача. Ми можемо
// використовувати цей тип скрізь, і ми використали
// його для двох змінних: user та userJack.

// Крім того, ми можемо використати interface для визначення об'єкта:

// interface User {
//   name: string;
//   age: number;
// }

// let user: User = {
//   name: "Tom",
//   age: 30,
// };

// export {};

// Загалом, типи та інтерфейси дозволяють покращити
// структуру та повторне використання коду, а також
// допомагають уникнути помилок за рахунок суворої типізації.

// В цьому разі немає суттєвої різниці між type та interface, у
// майбутніх блоках ми розберемо їх докладніше.

//  ================================

// Array

// Масиви в TypeScript — це структури, які є впорядкованим
// набором елементів. Для оголошення масиву в TypeScript
// використовується конструкція з квадратними дужками []
// або загальний тип Array.

// Якщо ми хочемо вказати масив рядків, ми робимо це так:

// let arrString: string[];

// Якщо ми спробуємо передати в нього не рядковий тип
// даних, ми отримаємо помилку.

// let arrString: string[];
// arrString = ["text", 1];
// export {}

// Як бачимо, число підсвітилося як помилка.
// Давайте створимо масив чисел:

// let arrNumber: number[];

// Тепер він може містити лише числа, і будь-який
// інший тип даних буде викликати помилку.

// let arrNumber: number[];
// arrNumber = [1, 'text'];
// export {}

// Крім того, масиви в TypeScript можуть
// бути багатовимірними. Наприклад:

// let matrix: number[][] = [
//   [1, 2],
//   [3, 4],
// ];

// Масиви також можуть містити елементи різних типів. Наприклад:
// let mixed: (number | string)[] = [1, "two"];

// Ми також можемо вказати тип масиву через узагальнення (generic):
// let numbers: Array<number> = [1, 2, 3, 4, 5];

// Можна визначити масив об'єктів у TypeScript. Наприклад:

// let users: {
//   name: string;
//   age: number;
// }[] = [
//   { name: "Tom", age: 30 },
//   { name: "Jack", age: 25 },
//   { name: "Alice", age: 32 },
// ];

// Або з використанням більш зручного запису:

// type User = {
//   name: string;
//   age: number;
// };

// let users: User[] = [
//   { name: "Tom", age: 30 },
//   { name: "Jack", age: 25 },
//   { name: "Alice", age: 32 },
// ];

// Тепер якщо якесь значення об'єкта буде не того типу, ми отримаємо помилку.

// type User = {
//   name: string;
//   age: number;
// };

// let users: User[] = [{ name: "Tom", age: '30' }];

// Це демонструє всю силу суворої типізації.
// Але іноді нам це не потрібно,
// і тоді ми можемо скористатися типом даних any:

// let arrAny: any[];

// У такому масиві можна зберігати будь-що.

// let arrAny: any[];
// arrAny = [123, "text", { name: "Tom" }, [1, 2, 3]];
// export { };

// Але не варто зловживати any, інакше TypeScript швидко перетвориться на JavaScript :)

/* ======================================================================================================================
Типи для змінних та аргументів
====================================================================================================================== */
// Any

// Any — це тип даних, який використовується, коли ви
// не знаєте, який тип даних може міститися у змінній.
// Змінні з типом any дозволяють викликати будь-які
// властивості та методи без перевірок типів. Цей тип
// даних робить змінну аналогічною змінною в JavaScript,
// що дозволяє передавати в неї будь-які значення. Однак,
// варто уникати використання типу any, оскільки це обходить
// переваги суворої типізації у TypeScript.

// let notSure: any = 4;
// notSure = "maybe a string instead";
// notSure = false;
// notSure = {};

// let num: number;
// num = notSure;
// export {};

// Основною проблемою використання типу any в TypeScript є
// відсутність суворої типізації. Зберігай його у змінну, де вказано тип.

// let num: number;
// num = notSure;

// У цьому випадку TypeScript не викличе помилку на етапі компіляції,
// адже any потенційно може являти собою будь-який тип даних. Навіть
// якщо з коду зрозуміло, що notSure — це об'єкт, а не число.

// Але в яких випадках він може бути корисним? Наприклад, коли ми
// працюємо з бібліотекою на JavaScript, що може повертати різні
// типи даних, або в ситуаціях, коли конкретний тип даних не має
// значення в контексті нашого коду.

// let data: any = fetchData();

// Або візьмемо інший приклад, коли функція приймає аргумент,
// тип якого нам не відомий, і який загалом не важливий у цьому
// контексті. Це може бути, наприклад, певна колбек-функція.

// function fetchUserData(id: string, callback: (data: any) => void): void {
//   // Тут може бути якийсь запит, але ми його заповнимо самі
//   const responseData = { name: "Tom" };
//   callback(responseData);
// }

// // Використання функції:
// fetchUserData("123", (data) => {
//   console.log(data.name); // TypeScript не викличе помилку, навіть якщо поле name не існує
// });

// export {};

// Це дозволяє нам працювати з даними, не знаючи їхньої точної структури.
// Однак це також означає, що TypeScript не зможе надати нам підказки про
// те, які властивості та методи доступні для об'єкта data.

// Unknown

// Тип unknown у TypeScript багато в чому схожий на any, але він
// забезпечує більше безпеки під час роботи зі змінними. Якщо ми
// спробуємо присвоїти значення змінної типу unknown іншій змінній
// з конкретним типом без явного приведення типів, TypeScript
// видасть помилку. Це допомагає запобігти випадковому присвоєнню
// значень неправильного типу.

// let notSure: unknown = 4;
// notSure = "maybe a string instead";
// notSure = false;

// let num: number;
// num = notSure;
// export {};

// Як бачимо, нам не вдалося зберегти значення
// змінної notSure в змінну num.

// Тип unknown підходить для сценаріїв, коли ви
// не знаєте точного типу даних, але все ж таки
// хочете підтримувати сувору перевірку типів.
// Змінні цього типу слід перевіряти перед їх використанням.

// Візьмемо для прикладу таку ситуацію: Ви отримуєте
// дані з API та не знаєте їхнього точного формату.
// У цьому випадку вам потрібно буде провести уточнення типів.

// function fetchUserData() {
//   return "Tom";
// }

// let userData: unknown = fetchUserData(); // fetchUserData повертає невідомі дані
// if (typeof userData === "string") {
//   console.log(userData.toUpperCase()); // OK, тепер ми знаємо, що це рядок
// }

// Отже, ми можемо бути впевнені, що обробляємо дані правильного типу.

// Tuple

// Кортеж, особливо популярний у мовах програмування як Python, це
// незмінний масив. У TypeScript це тип даних, що дозволяє визначити
// масив з фіксованою кількістю елементів, типи яких відомі, але не
// обов'язково повинні бути однаковими.

// Він створюється як масив, але замість значень ми передаємо
// типи даних, наприклад, [string, number].

// let tupleType: [string, boolean];
// tupleType = ["hello", true]; // OK
// tupleType = [true, "hello"]; // Error. Неправильні типи
// tupleType = ["hello", true, true]; // Error. Більше значень ніж у tuple

// export {};

// Кортежі зручні, коли нам потрібно зберегти в масив
// фіксовані значення, наприклад, день, місяць та рік.

// let date: [number, number, number];
// date = [7, 11, 2023]; // OK

// Але є нюанс: якщо ми додамо елемент у кортеж
// через метод push, то TypeScript не заперечуватиме,
// він не відстежує реальний вміст масиву.

// let fixed: [string, number];
// fixed = ["Text", 10];
// fixed.push("Add this text");
// export {};

// Як ми бачимо, компілятор не зміг розібратися і видати помилку.

// Однак, TypeScript надає гнучкі можливості для роботи з
// кортежами, включно з використанням оператора розширення
// (...) для створення кортежів змінної довжини.

// let tuple: [string, ...number[]];
// tuple = ["hello", 42, 100, 200];

// У цьому випадку перший елемент
// кортежу має бути рядком, проте всі наступні — числами.

// Enum

// Ця структура настільки широко використовується, що в
// TypeScript вирішили додати її як тип даних. Цей тип
//  називається enum і, згідно з хорошими практиками
// програмування, імена змінних цього типу мають починатися з великої літери.

// enum Role {
//   ADMIN,
//   USER,
// }

// Розглянемо застосування на прикладі користувача, який має певні права.

// enum Role {
//   ADMIN,
//   USER,
// }

// const person = {
//   role: Role.ADMIN,
// };

// if (person.role === Role.ADMIN) {
//   console.log("Role", Role.ADMIN); // Role:  0
//   console.log(Role[Role.ADMIN]); // значення enum // "ADMIN"
// }

// export {};

// Enum являє собою набір констант, що робить код більш
//  зрозумілим. Як ми бачили у минулому прикладі,
//  значеннями enum зазвичай є числа, проте ми можемо задати свої значення.

// enum UserStatus {
//   Active = "ACTIVE",
//   Inactive = "INACTIVE",
//   Banned = "BANNED",
// }

// let status: UserStatus = UserStatus.Active;

// Крім того, ви можете використовувати enum для
// угруповання взаємопов'язаних значень, що може
// бути корисним для спрощення коду та покращення читабельності:

// enum HttpCodes {
//   Ok = 200,
//   BadRequest = 400,
//   Unauthorized = 401,
// }

// function respond(status: HttpCodes) {
//   // handle response
// }

// respond(HttpCodes.Ok);
// export {};

// Коли ми будемо створювати свої типи, детальніше розберемо,
// як enum може допомогти нам у цьому процесі.

// Існує ще така конструкція, як const enum. На відміну від
// звичайного enum, const enum видаляється під час транспіляції
// та не створює додаткового об'єкта в JavaScript.

// Значення const enum вставляють у місце використання у вигляді
// літералів. Це може допомогти покращити продуктивність.

// const enum HttpCodes {
//   Ok = 200,
//   BadRequest = 400,
//   Unauthorized = 401,
// }

// const status = HttpCodes.Ok;

// Після компіляції у JavaScript отримаємо наступний код:

// const status = 200;

// Як видно з прикладу, const enum видаляється зі
// скомпільованого коду і його значення прямо
// вставляється в код. У цьому випадку HttpCodes.
// OK замінився на 200. Це і є ключовою відмінністю
//  const enum від звичайного enum.

// Однак існує одне обмеження використання const enum:
// їх не можна використовувати у виразах, які вимагають
// виконання під час виконання. Це пов'язане з тим, що
// вони замінюються на їхнє значення під час компіляції.

// const enum Test {
//   A = 1,
//   B = 2,
// }

// for (let item in Test) {
//   console.log(item);
// }

// export {};

// ==================

// Union Type

// Union Type у TypeScript дозволяє вказати, що
// значенням може бути один із кількох типів. Це
// дуже зручно, коли хочемо визначити змінну,
// яка може приймати різні типи даних. Типи
// перераховуються через вертикальну риску |

// let mixedType: string | number | boolean;

// Давайте подивимося, як це працює:

// let mixedType: string | number | boolean;

// mixedType = "string"; // Ok
// mixedType = 10; // Ok
// mixedType = true; // Ok
// mixedType = {}; // Error: Type '{}' is not assignable to type 'string | number | boolean'.

// export {};

// Union Type можна також використовувати для аргументів
// функцій. Давайте створимо функцію, яка об'єднує рядки або складає числа.

// function combine(param1: number | string, param2: number | string) {
//   return param1 + param2;
// }
// export {}

// Ми отримуємо помилку, тому що TypeScript просто не знає, рядок там чи число.

// Давайте перевіримо типи у функції.

// function combine(param1: number | string, param2: number | string) {
//   if (typeof param1 === "number" && typeof param2 === "number") {
//     return param1 + param2;
//   } else {
//     return param1.toString() + param2.toString();
//   }
// }
// export {};

// Тепер ми можемо передавати у функцію або числа, або рядки.

// Union Type працює не лише з базовими типами, а й з об'єктами:

// type Dog = {
//   legs: 4;
//   bark: () => void;
// };

// type Fish = {
//   fins: 2;
//   swim: () => void;
// };

// let pet: Dog | Fish;

// У цьому прикладі змінна pet може бути або
// об'єктом типу Dog, або об'єктом типу Fish.

// Однак існує важливе обмеження: коли ми працюємо
// зі змінною Union Type, ми можемо використовувати
// лише ті властивості та методи, які існують у всіх
// типів цього об'єднання. У прикладі вище ми не
// можемо викликати pet.bark(), якщо pet є типом Fish.
// Нам доведеться перевіряти, чи існує цей метод.

// type Dog = {
//   legs: 4;
//   bark: () => void;
// };

// type Fish = {
//   fins: 2;
//   swim: () => void;
// };

// let pet: Dog | Fish;

// // type guard function
// function isDog(pet: Dog | Fish): pet is Dog {
//   return "bark" in pet;
// }

// // Перевіряємо, чи є наш вихованець собакою перед тим, як використовувати метод bark
// if (isDog(pet)) {
//   pet.bark(); // OK, тепер TypeScript знає, що pet - це Dog
// } else {
//   pet.swim(); // TypeScript знає, що якщо pet не Dog, то це має бути Fish
// }

// export {};

// Дуже часто розробники вважають за краще використовувати
// Union Type замість enum для перерахування всіх допустимих
// значень. Це особливо зручно робити у зв'язці з Literal Type.

// =================================

// Intersection Type

// Intersection type є способом об'єднання декількох типів в один.
// Це дозволяє створювати складні типи, комбінуючи прості.
// У TypeScript можна використовувати символ & для створення типу intersection.

// type Employee = {
//   name: string;
//   id: number;
// };

// type Manager = {
//   employees: Employee[];
// };

// type CEO = Employee & Manager;

// const ceo: CEO = {
//   name: "Alice",
//   id: 1,
//   employees: [
//     {
//       name: "Bob",
//       id: 2,
//     },
//   ],
// };

// export {};

// У цьому прикладі CEO є intersection тип Employee і Manager.
//  Це означає, що об'єкт типу CEO повинен містити всі властивості,
// визначені в Employee та Manager.

// ==================================

// Literal Type

// Literal Type — це тип, що набуває конкретного значення.
// З ним ви можете визначити тип змінної так,
// щоб він набував лише певних значень.

// type OneOrTwo = 1 | 2;
// let value: OneOrTwo;
// value = 1; // Ok
// value = 2; // Ok
// value = 3; // Error: Type '3' is not assignable to type 'OneOrTwo'.

// type YesOrNo = "yes" | "no";
// let answer: YesOrNo;
// answer = "yes"; // Ok
// answer = "no"; // Ok
// answer = "maybe"; // Error: Type '"maybe"' is not assignable to type 'YesOrNo'.

// export {};

// Тут OneOrTwo може набувати лише значення 1 або 2,
// YesOrNo може набувати тільки значення "yes" або "no".

// Але давайте розглянемо якийсь бойовий приклад.
// Припустимо, ми маємо функцію, що приймає рядок як
// аргумент і повертає стилі для кнопки в залежності
// від переданого значення.

// type ButtonSize = "small" | "medium" | "large";

// function getButtonSize(size: ButtonSize) {
//   switch (size) {
//     case "small":
//       return { fontSize: "10px", padding: "5px" };
//     case "medium":
//       return { fontSize: "14px", padding: "10px" };
//     case "large":
//       return { fontSize: "18px", padding: "15px" };
//     default:
//       return { fontSize: "14px", padding: "10px" };
//   }
// }

// let myButtonStyle = getButtonSize("medium"); // OK
// myButtonStyle = getButtonSize("extra-large"); // Error: Argument of type '"extra-large"' is not assignable to parameter of type 'ButtonSize'.

// export {};

// Тут, якщо ми спробуємо викликати функцію getButtonStyle
// з аргументом "extra-large", TypeScript видасть помилку
// на етапі компіляції, оскільки "extra-large" не є
// допустимим значенням для ButtonSize.
